# defines the VulnerabilityTest as well as specific tests
from enum import Enum
import re
from core.scan_result import ScanResult
from core.http_interface import HTTPInterface

class VulnerabilityTest:
    def __init__(self):
        self.name = ""
        self.description = ""
        self.risk_level = ""
        self.category = ""
        self.stats = {
            'total_endpoints': 0,
            'vulnerable_endpoints': 0,
            'high_risk': 0,
            'medium_risk': 0,
            'low_risk': 0
        }
        self.flags_set = False

    def update_flags(self):
        self.flags_set = False

    def run_test(self, api_client):
        print("do something")

    def _set_flag(self, api_client):
        # Helper function, call in run_test
        # Set's the appropriate flags for each endpoint in the api_client
        # Make sure to update flags_set to true at the end of each _set_flag
        print("do something")

#Flags enum
class OWASP_FLAGS(Enum):
    BOLA = "1. Broken Object Level Authorization"
    BKEN_AUTH = "2. Broken Authentication"
    BOPLA = "3. Broken Object Property Level Authorization"
    URC = "4. Unrestricted Resource Consumption"
    BFLA = "5. Broken Function Level Authorization"
    UABF = "6. Unrestricted Access to Sensitive Business Flows"
    SSRF = "7. Server Side Request Forgery"
    SEC_MISC = "8. Security Misconfiguration"
    IIM = "9. Improper Inventory Management"
    UCAPI = "10. Unsafe Consumption of APIs"
    SKIP = "Don't test this endpoint"

# Used to describe Failure cases when attempting to set flags
class ENDPOINT_FLAGS(Enum):
    SUCCESS = "Flag Set"
    FAILED = "Failed to set flags for endpoints"

class BOLA_Scan(VulnerabilityTest):
    def __init__(self):
        super().__init__()
        self.name = OWASP_FLAGS.BOLA
        self.description = "Tests control issues related to object access with identifiers"
        self.risk_level = "High"
        self.category = "Authorization"
        self.endpoints = []

    def _set_flag(self, api_client):
        print("Setting flags for BOLA")
        # if self.flags_set == True:
        #     return ENDPOINT_FLAGS.SUCCESS
        #     

        self.object_id_patterns = [
            r'\{id\}',
            r'\{userId\}',
            r'\{user_id\}',
            r'\{[a-zA-Z]*[Ii]d\}',
            r'\{[a-zA-Z]*_id\}'
        ]

        self.sensitive_id_patterns = [
            r'\{userId\}',
            r'\{user_id\}',
            r'\{accountId\}',
            r'\{account_id\}',
            r'\{orderId\}',
            r'\{order_id\}',
            r'\{documentId\}',
            r'\{document_id\}',
            r'\{fileId\}',
            r'\{file_id\}',
            r'\{resourceId\}',
            r'\{resource_id\}',
            r'\{invoiceId\}',
            r'\{invoice_id\}',
            r'\{sessionId\}',
            r'\{session_id\}',
        ]

        # Iterate throuh each endpoint in the api client
        # If it matches the below criteria criteria use endpoint.add_flag(OWASP_FLAGS.BOLA)
        # Criteria: 
            # endpoint.path must have a regex match in object_id_patterns
                # endpoint.check_auth() is true
                # matches someting in sensitive_id_patterns
        # if something goes wrong return ENDPOINT_FLAGS.FAILED

        try:
            for endpoint in api_client.endpoints:
                path = endpoint.path
                # print(f"Flag Check: {path}")

                if any(re.search(pattern, path) for pattern in self.object_id_patterns):
                    if endpoint.check_auth():
                        if any(re.search(pattern, path) for pattern in self.sensitive_id_patterns):
                            endpoint.add_flag(OWASP_FLAGS.BOLA)
                            self.endpoints.append(endpoint)

            self.flags_set = True
            return ENDPOINT_FLAGS.SUCCESS

        except Exception as e:
            print(f"[ERROR] Failed to set BOLA flag: {e}")
            return ENDPOINT_FLAGS.FAILED
    
    
#Things to try
    # Use api key to store valid information, try to tamper with this information to access other data
    # ID tampering
    # Look at server responses 
    # accessing objects: /orders?id=123 and /orders/{id}
    # OpenAPI may reveal data type in the spec?
    # heuristics: look for int, try to incement, look for uuid etc

    def run_test(self, api_client):
    # Assume api_client.auth_token is set and valid

        # Deprecated
        # if self._set_flag(api_client) != ENDPOINT_FLAGS.SUCCESS:
        #     print("Failed to set flags")
        #     return

        results = []

        url = api_client.get_url()
        http_interface = HTTPInterface(url)
        http_interface.add_header(api_client.get_auth_header())

        for endpoint in self.endpoints:
            if OWASP_FLAGS.BOLA not in endpoint.get_flags():
                continue

            if OWASP_FLAGS.SKIP in endpoint.get_flags():
                continue

            # print(f"[Testing] {endpoint.method} {endpoint.path}")

            #try to extract ID 
            candidate_ids = []
            for param in endpoint.parameters:
                name = param.get("name", "")
                if "id" in name.lower():
                    schema = param.get("schema", {})
                    param_type = schema.get("type", "string")

                    #generate test id's
                    if param_type == "integer":
                        candidate_ids.extend(["1", "2", "999", "1001"])
                    elif param_type == "string":
                        candidate_ids.extend([
                            "11111111-1111-1111-1111-111111111111",  # UUID
                            "not-a-valid-id", 
                            "test", 
                            "123456"
                        ])

            #test tampered id's
            for test_id in candidate_ids:
                test_path = endpoint.path
                if "{" in test_path:
                    test_path = re.sub(r"\{[^}]*id[^}]*\}", test_id, test_path, flags=re.IGNORECASE)

                params = {}
                for param in endpoint.parameters:
                    if param.get("in") == "query" and "id" in param.get("name", "").lower():
                        params[param["name"]] = test_id

                response = http_interface.send_custom(endpoint.method, test_path, params=params)
                # print(f"  -> {response.status_code} for ID: {test_id}")

                #Return scan_result object
                if response.status_code == 200:
                    # print("  [!] Potential BOLA: Access granted with tampered ID")
                    # return scan result
                    scan_evidence = f"Method: {endpoint.method}\nPath: {test_path}\nParameters: {params}"
                    sr = ScanResult(
                        1,
                        OWASP_FLAGS.BOLA.value,
                        endpoint,
                        self.risk_level, 
                        10,
                        "Endpoint allows us to access data of other users by tampering with id's",
                        "Properly authenticate before returning data",
                        scan_evidence,
                        "Basic ID tampering",
                        params
                        )

                    results.append(sr)
                elif response.status_code == 401:
                    endpoint.add_flag(ENDPOINT_FLAGS.FAILED)

        return results


class BKEN_AUTH_Scan(VulnerabilityTest):
    def __init__(self):
        super().__init__()
        self.name = OWASP_FLAGS.BKEN_AUTH
        self.description = "Tests for authentication mechanism weaknesses"
        self.risk_level = "High"
        self.category = "Authentication"
        self.endpoints = []

    def _set_flag(self, api_client):
        print("Setting flags for BKEN_AUTH")
        try:
            for endpoint in api_client.endpoints:
                if endpoint.check_auth():
                    endpoint.add_flag(OWASP_FLAGS.BKEN_AUTH)
                    self.endpoints.append(endpoint)
            self.flags_set = True
            return ENDPOINT_FLAGS.SUCCESS
        except Exception as e:
            print(f"[ERROR] Failed to set BKEN_AUTH flag: {e}")
            return ENDPOINT_FLAGS.FAILED

    def run_test(self, api_client):
        if self._set_flag(api_client) != ENDPOINT_FLAGS.SUCCESS:
            return []
        results = []
        # Test authentication mechanisms
        for endpoint in self.endpoints:
            if OWASP_FLAGS.BKEN_AUTH not in endpoint.get_flags():
                continue
            # Send request without auth token
            http_interface = HTTPInterface(api_client.get_url())
            response = http_interface.send_custom(endpoint.method, endpoint.path)
            if response.status_code != 401:
                scan_evidence = f"Method: {endpoint.method}\nPath: {endpoint.path}\nStatus: {response.status_code}"
                sr = ScanResult(
                    2,
                    OWASP_FLAGS.BKEN_AUTH.value,
                    endpoint,
                    self.risk_level,
                    10,
                    "Authentication mechanism weakness: endpoint does not return 401 status code",
                    "Implement proper authentication mechanism",
                    scan_evidence,
                    "Authentication bypass",
                    {}
                )
                results.append(sr)
        return results

class BOPLA_Scan(VulnerabilityTest):
    def __init__(self):
        super().__init__()
        self.name = OWASP_FLAGS.BOPLA
        self.description = "Tests for object property level authorization issues"
        self.risk_level = "High"
        self.category = "Authorization"
        self.endpoints = []

    # Data exposure + Mass Assignment
    # Data exposure: look for sensitive key words +/ data format in returned responses
        # Look for things like gov id, email, dob etc..
        # Get endpoints that return data
    # Mass assignment: Look for sensitive fields within api docs, like admin=true
        # Set field and make a request
        # Look for endpoints that accept properpties in the requet field (PUT, PATCH POST)

    def _set_flag(self, api_client):
        print("Setting flags for BOPLA")
        sensitive_props = [
            "ssn", "social", "password", "pass", "role", "is_admin", "admin",
            "balance", "internal", "profit_margin", "internal_notes", "credit_card",
            "card_number", "secret", "token", "account", "owner_id", "ssn_number"
        ]
        resource_keywords = ["user", "account", "invoice", "order", "customer", "profile"]

        try:
            for endpoint in api_client.endpoints:
                marked = False
                method = (endpoint.method or "").upper()
                path = endpoint.path or ""
                summary = (endpoint.summary or "") + " " + (endpoint.description or "")
                tags = " ".join(endpoint.tags or "")

                # 1) Request body presence or schema indicating arbitrary properties -> mass-assignment candidate
                rb = endpoint.request_body or {}
                if isinstance(rb, dict) and rb.get("content"):
                    # If explicit schema properties present, check names
                    for _, content_schema in rb.get("content", {}).items():
                        schema = content_schema.get("schema", {}) if isinstance(content_schema, dict) else {}
                        # check explicit properties for sensitive names
                        props = schema.get("properties", {}) if isinstance(schema.get("properties", {}), dict) else {}
                        for prop in props.keys():
                            if any(sp in prop.lower() for sp in sensitive_props):
                                endpoint.add_flag(OWASP_FLAGS.BOPLA)
                                self.endpoints.append(endpoint)
                                marked = True
                                break
                        if marked:
                            break

                        # check additionalProperties true -> suspicious (allows arbitrary properties)
                        if schema.get("additionalProperties") is True:
                            endpoint.add_flag(OWASP_FLAGS.BOPLA)
                            self.endpoints.append(endpoint)
                            marked = True
                            break

                    # if requestBody exists but no schema details -> for PATCH/PUT/POST mark as suspect
                    if not marked and method in ("PATCH", "PUT", "POST"):
                        endpoint.add_flag(OWASP_FLAGS.BOPLA)
                        self.endpoints.append(endpoint)
                        marked = True

                if marked:
                    continue

                # 2) Response schemas / examples -> excessive exposure
                responses = endpoint.responses or {}
                if isinstance(responses, dict):
                    for resp_info in responses.values():
                        if not isinstance(resp_info, dict):
                            continue
                        contents = resp_info.get("content", {}) if isinstance(resp_info.get("content", {}), dict) else {}
                        for _, content_schema in contents.items():
                            schema = content_schema.get("schema", {}) if isinstance(content_schema, dict) else {}
                            props = schema.get("properties", {}) if isinstance(schema.get("properties", {}), dict) else {}
                            for prop in props.keys():
                                if any(sp in prop.lower() for sp in sensitive_props):
                                    endpoint.add_flag(OWASP_FLAGS.BOPLA)
                                    self.endpoints.append(endpoint)
                                    marked = True
                                    break
                            if marked:
                                break

                            # examples may reveal fields even if schema is empty
                            example = content_schema.get("example")
                            if isinstance(example, dict):
                                for k in example.keys():
                                    if any(sp in k.lower() for sp in sensitive_props):
                                        endpoint.add_flag(OWASP_FLAGS.BOPLA)
                                        self.endpoints.append(endpoint)
                                        marked = True
                                        break
                            if marked:
                                break
                        if marked:
                            break

                if marked:
                    continue

                # 3) Heuristic: path/summary/description/tags indicate resource or sensitive content -> suspect
                lowered = (path + " " + summary + " " + tags).lower()
                if any(k in lowered for k in resource_keywords) or any(sp in lowered for sp in sensitive_props):
                    # mark GET for excessive exposure suspicion
                    if method in ("GET",):
                        endpoint.add_flag(OWASP_FLAGS.BOPLA)
                        self.endpoints.append(endpoint)
                        continue
                    # mark modifying methods as mass-assignment suspects
                    if method in ("PATCH", "PUT", "POST"):
                        endpoint.add_flag(OWASP_FLAGS.BOPLA)
                        self.endpoints.append(endpoint)
                        continue

                # 4) Parameter names that look sensitive -> suspect
                for p in endpoint.parameters or []:
                    pname = p.get("name", "").lower()
                    if any(sp in pname for sp in sensitive_props):
                        endpoint.add_flag(OWASP_FLAGS.BOPLA)
                        self.endpoints.append(endpoint)
                        marked = True
                        break

            self.flags_set = True
            return ENDPOINT_FLAGS.SUCCESS

        except Exception as e:
            print(f"[ERROR] Failed to set BOPLA flag: {e}")
            return ENDPOINT_FLAGS.FAILED

    def run_test(self, api_client):
        # Ensure flags are set

        # Deprecated
        # if self._set_flag(api_client) != ENDPOINT_FLAGS.SUCCESS:
        #     print("Failed to set flags for BOPLA")
        #     return

        base_url = api_client.get_url()
        http_interface = HTTPInterface(base_url)

        try:
            auth_hdr = api_client.get_auth_header()
            http_interface.add_header(auth_hdr)
        except Exception:
            pass

        results = []

        test_payload = {
            "role": "admin",
            "is_admin": True,
            "ssn": "999-99-9999",
            "password": "Compromised123!",
            "internal_notes": "injected_by_scanner"
        }

        try:
            http_interface.add_header("Content-Type: application/json")
        except Exception:
            pass

        for endpoint in self.endpoints:
            if OWASP_FLAGS.BOPLA not in endpoint.get_flags():
                continue

            if OWASP_FLAGS.SKIP in endpoint.get_flags():
                continue

            path = endpoint.path
            test_path = path
            if "{" in test_path:
                # find a simple numeric or uuid replacement using parameters if available
                replacement = "1"
                try:
                    for p in endpoint.parameters:
                        if "id" in p.get("name", "").lower():
                            schema = p.get("schema", {})
                            if schema.get("type") == "integer":
                                replacement = "1"
                            elif schema.get("type") == "string":
                                replacement = "11111111-1111-1111-1111-111111111111"
                            break
                except Exception:
                    replacement = "1"
                # replace any {..id..} style placeholder
                test_path = re.sub(r"\{[^}]*id[^}]*\}", replacement, test_path, flags=re.IGNORECASE)

            # Excessive Data Exposure: 
            # GET/HEAD/OPTIONS
            # request resource and look for sensitive fields in response
            if endpoint.method.upper() in ("GET", "HEAD", "OPTIONS"):
                try:
                    resp = http_interface.send_custom(endpoint.method, test_path)
                except Exception as e:
                    print(f"[WARN] Request failed for {endpoint.method} {test_path}: {e}")
                    continue

                try:
                    if resp.status_code == 200:
                        content_type = resp.headers.get("Content-Type", "")
                        body_json = None
                        if "application/json" in content_type:
                            try:
                                body_json = resp.json()
                            except Exception:
                                body_json = None

                        if isinstance(body_json, dict):
                            found = []
                            for k in body_json.keys():
                                kl = k.lower()
                                if any(sp in kl for sp in ["ssn", "social", "password", "role", "is_admin", "internal", "profit", "credit", "card", "secret", "token"]):
                                    found.append(k)

                            if found:
                                scan_evidence = f"Method: {endpoint.method}\nPath: {test_path}\nReturned fields: {found}"
                                sr = ScanResult(
                                    3,
                                    OWASP_FLAGS.BOPLA.value,
                                    endpoint,
                                    self.risk_level,
                                    9,
                                    "Endpoint returns sensitive fields in responses (excessive data exposure).",
                                    "Implement response filtering/allow-listing and remove sensitive fields from API responses.",
                                    scan_evidence,
                                    "Excessive Data Exposure - top-level sensitive properties returned",
                                    {"returned_fields": found}
                                )
                                results.append(sr)
                except Exception as e:
                    print(f"[ERROR] While analyzing GET response for {test_path}: {e}")
                    continue

            # Mass-assignment
            # alter properties and see if it works 
            if endpoint.method.upper() in ("PATCH", "PUT", "POST"):
                # set body on interface (HTTPInterface will JSON dump if Content-Type is application/json)
                try:
                    http_interface.set_body(test_payload)
                    resp = http_interface.send_custom(endpoint.method, test_path)
                except Exception as e:
                    print(f"[WARN] Modify attempt failed for {endpoint.method} {test_path}: {e}")
                    # clear body and continue
                    http_interface.clear_body()
                    continue

                # If server acknowledges change with 200 or returns a body that echoes the injected fields, treat as potential vuln
                try:
                    if resp.status_code in (200, 201, 202, 203, 204):
                        echoed = []
                        body_json = None
                        content_type = resp.headers.get("Content-Type", "")
                        if "application/json" in content_type:
                            try:
                                body_json = resp.json()
                            except Exception:
                                body_json = None

                        if isinstance(body_json, dict):
                            for key, val in test_payload.items():
                                if key in body_json and body_json.get(key) == val:
                                    echoed.append(key)

                        # If server returned/echoed sensitive properties, flag as vulnerability
                        if echoed:
                            scan_evidence = (
                                f"Method: {endpoint.method}\nPath: {test_path}\n"
                                f"Attempted to set: {list(test_payload.keys())}\n"
                                f"Server echoed/accepted: {echoed}\nStatus: {resp.status_code}"
                            )
                            sr = ScanResult(
                                3,
                                OWASP_FLAGS.BOPLA.value,
                                endpoint,
                                self.risk_level,
                                10,
                                "Endpoint allows modification or returns sensitive properties (mass-assignment / excessive exposure).",
                                "Use allow-lists for writable fields, validate and sanitize request bodies, and remove sensitive fields from responses.",
                                scan_evidence,
                                "Mass assignment / excessive data exposure combined test",
                                {"attempted_payload": test_payload, "accepted_fields": echoed}
                            )
                            # cleanup and return
                            http_interface.clear_body()
                            results.append(sr)

                        # As an extra heuristic, if we got 204/200 but no echo, try a GET to verify persistence (best-effort)
                        if resp.status_code in (200, 204):
                            try:
                                # Attempt to GET the resource to confirm change
                                verify_resp = http_interface.send_custom("GET", test_path)
                                verify_json = None
                                if verify_resp.status_code == 200 and "application/json" in verify_resp.headers.get("Content-Type", ""):
                                    try:
                                        verify_json = verify_resp.json()
                                    except Exception:
                                        verify_json = None

                                persisted = []
                                if isinstance(verify_json, dict):
                                    for key, val in test_payload.items():
                                        if key in verify_json and verify_json.get(key) == val:
                                            persisted.append(key)

                                if persisted:
                                    scan_evidence = (
                                        f"Method: {endpoint.method}\nPath: {test_path}\n"
                                        f"Attempted to set: {list(test_payload.keys())}\n"
                                        f"Persisted fields: {persisted}\n"
                                        f"Modify status: {resp.status_code}\nVerify status: {verify_resp.status_code}"
                                    )
                                    sr = ScanResult(
                                        1,
                                        OWASP_FLAGS.BOPLA.value,
                                        endpoint,
                                        self.risk_level,
                                        10,
                                        "Endpoint allowed updating sensitive properties (mass-assignment).",
                                        "Use allow-lists for writable fields, enforce server-side checks on which properties can be updated, and never trust client input to control authorization.",
                                        scan_evidence,
                                        "Mass assignment confirmed via persistence check",
                                        {"attempted_payload": test_payload, "persisted_fields": persisted}
                                    )
                                    http_interface.clear_body()
                                    results.append(sr)

                            except Exception:
                                # verification failed — move to next endpoint
                                pass

                except Exception as e:
                    print(f"[ERROR] While analyzing modify response for {test_path}: {e}")
                finally:
                    http_interface.clear_body()

        return results

# class URC_Scan(VulnerabilityTest):
#     def __init__(self):
#         super().__init__()
#         self.name = OWASP_FLAGS.URC
#         self.description = "Tests for unrestricted resource consumption vulnerabilities"
#         self.risk_level = "Medium"
#         self.category = "Resource Management"
#         self.endpoints = []

#     def _set_flag(self, api_client):
#         print("Setting flags for URC")
#         try:
#             for endpoint in api_client.endpoints:
#                 # Check if endpoint consumes resources
#                 if endpoint.method in ["POST", "PUT", "PATCH"]:
#                     endpoint.add_flag(OWASP_FLAGS.URC)
#                     self.endpoints.append(endpoint)
#             self.flags_set = True
#             return ENDPOINT_FLAGS.SUCCESS
#         except Exception as e:
#             print(f"[ERROR] Failed to set URC flag: {e}")
#             return ENDPOINT_FLAGS.FAILED

#     def run_test(self, api_client):
#         if self._set_flag(api_client) != ENDPOINT_FLAGS.SUCCESS:
#             return []
#         results = []
#         # Test resource consumption
#         for endpoint in self.endpoints:
#             if OWASP_FLAGS.URC not in endpoint.get_flags():
#                 continue
#             # Send multiple requests to test resource consumption
#             http_interface = HTTPInterface(api_client.get_url())
#             for i in range(10):
#                 response = http_interface.send_custom(endpoint.method, endpoint.path)
#                 if response.status_code != 200:
#                     break
#             if response.status_code == 429:
#                 # Rate limit exceeded, potential vulnerability
#                 scan_evidence = f"Method: {endpoint.method}\nPath: {endpoint.path}\nStatus: {response.status_code}"
#                 sr = ScanResult(
#                     4,
#                     OWASP_FLAGS.URC.value,
#                     endpoint,
#                     self.risk_level,
#                     8,
#                     "Unrestricted resource consumption vulnerability: rate limit exceeded",
#                     "Implement rate limiting",
#                     scan_evidence,
#                     "Rate limit exceeded",
#                     {}
#                 )
#                 results.append(sr)
#         return results




class BFLA_Scan(VulnerabilityTest):
    def __init__(self):
        super().__init__()
        self.name = OWASP_FLAGS.BFLA
        self.description = "Tests for function level authorization issues"
        self.risk_level = "High"
        self.category = "Authorization"
        self.endpoints = []

    # Allows users to alter or delete data they're not supposed to
    # able to transact on behalf on another user without their permission
    # Mark endpoints that can alter data
    # try to alter data for another user
    # GET on internal/admin endpoints, look for secrets in return
    # Attempt some action on internal/admin, look for success 

    def _set_flag(self, api_client):
        print("Setting flags for BFLA")
        try:
            # reset tracked endpoints so repeated runs stay in-sync
            self.endpoints = []

            keywords_admin = ["admin", "/admin/", "promote", "internal", "delete user", "delete-user", "delete_user"]
            # add update / edit user once we figure out how to store and manipulate user indentity formats
     
            for endpoint in api_client.endpoints:
                path = (endpoint.path or "").lower()
                summary = (endpoint.summary or "").lower()
                desc = (endpoint.description or "").lower()
                combined = " ".join([path, summary, desc])

                # mark endpoints that look like admin/internal actions
                if any(k in combined for k in keywords_admin):
                    if OWASP_FLAGS.BFLA not in endpoint.get_flags():
                        endpoint.add_flag(OWASP_FLAGS.BFLA)
                    if endpoint not in self.endpoints:
                        self.endpoints.append(endpoint)

                # also consider tags, note ATAT user has control over tags
                for t in endpoint.tags or []:
                    if isinstance(t, str) and ("admin" in t.lower() or "internal" in t.lower()):
                        if OWASP_FLAGS.BFLA not in endpoint.get_flags():
                            endpoint.add_flag(OWASP_FLAGS.BFLA)
                        if endpoint not in self.endpoints:
                            self.endpoints.append(endpoint)
                        break

            self.flags_set = True
            return ENDPOINT_FLAGS.SUCCESS
        except Exception:
            return ENDPOINT_FLAGS.FAILED

    def run_test(self, api_client):
        """
        Run BFLA tests on endpoints flagged by _set_flag.
        Returns a list of ScanResult objects (may be empty).
        This implementation:
        - scans lists returned by GET endpoints for sensitive keys
        - when attempting actions (promote/delete), tries to pick a valid id by probing collection endpoints (e.g. /admin/users)
        """

        # Deprecated
        # if self._set_flag(api_client) != ENDPOINT_FLAGS.SUCCESS:
        #     return []

        base_url = api_client.get_url()
        http_interface = HTTPInterface(base_url)

        # best-effort auth header
        try:
            auth_hdr = api_client.get_auth_header()
            http_interface.add_header(auth_hdr)
        except Exception:
            pass

        results = []

        # Helper: choose replacement for path params. If possible, probe collection endpoints to find a valid id.
        def _choose_replacement(ep):
            # 1) try to use schema if present
            try:
                for p in ep.parameters or []:
                    pname = p.get("name", "").lower()
                    schema = p.get("schema", {}) or {}
                    if "id" in pname:
                        if schema.get("type") == "integer":
                            return "1"
                        else:
                            return "11111111-1111-1111-1111-111111111111"
            except Exception:
                pass

            # 2) try to find a collection endpoint to discover an existing id (best-effort)
            try:
                for e2 in api_client.endpoints:
                    if e2.method and e2.method.upper() == "GET":
                        if e2.path and e2.path.rstrip("/").endswith("/users"):
                            try:
                                resp = http_interface.send_custom("GET", e2.path)
                                if resp and resp.status_code == 200:
                                    try:
                                        body = resp.json()
                                    except Exception:
                                        body = None
                                    if isinstance(body, list) and len(body) > 0:
                                        first = body[0]
                                        if isinstance(first, dict):
                                            for k in ("id", "user_id", "userId", "uid"):
                                                if k in first:
                                                    return str(first[k])
                                            for v in first.values():
                                                if isinstance(v, int):
                                                    return str(v)
                                        elif isinstance(first, int):
                                            return str(first)
                            except Exception:
                                pass
                return "1"
            except Exception:
                return "1"

        sensitive_keys_in_config = [
            "database_url", "api_key", "api_keys", "secret", "debug",
            "password", "token", "api_keys", "debug_mode"
        ]


        for endpoint in self.endpoints:
            if OWASP_FLAGS.BFLA not in endpoint.get_flags():
                continue

            if OWASP_FLAGS.SKIP in endpoint.get_flags():
                continue
                
            method = (endpoint.method or "").upper()
            path = endpoint.path or ""
            test_path = path

            if "{" in test_path:
                replacement = _choose_replacement(endpoint)
                test_path = re.sub(r"\{[^}]*\}", replacement, test_path)

            if method == "GET":
                try:
                    resp = http_interface.send_custom("GET", test_path)
                except Exception:
                    continue

                if resp is None:
                    continue

                body = None
                try:
                    body = resp.json()
                except Exception:
                    pass

                try:
                    found = []
                    if isinstance(body, dict):
                        for k in body.keys():
                            if any(sk in k.lower() for sk in sensitive_keys_in_config):
                                found.append(k)
                        if not found:
                            for v in body.values():
                                if isinstance(v, dict):
                                    for k2 in v.keys():
                                        if any(sk in k2.lower() for sk in sensitive_keys_in_config):
                                            found.append(k2)
                    elif isinstance(body, list) and len(body) > 0:
                        limit = min(5, len(body))
                        for i in range(limit):
                            item = body[i]
                            if isinstance(item, dict):
                                for k in item.keys():
                                    if any(sk in k.lower() for sk in sensitive_keys_in_config):
                                        if k not in found:
                                            found.append(k)
                    if found:
                        scan_evidence = f"Method: GET\nPath: {test_path}\nReturned keys: {found}\nStatus: {resp.status_code}"
                        sr = ScanResult(
                            5,
                            OWASP_FLAGS.BFLA.value,
                            endpoint,
                            self.risk_level,
                            9,
                            "Internal/admin GET endpoint returns sensitive configuration or secrets.",
                            "Restrict access to internal/admin endpoints by enforcing proper role checks and remove secrets from responses.",
                            scan_evidence,
                            "Exposed internal/admin data",
                            {"returned_keys": found}
                        )
                        results.append(sr)
                except Exception:
                    pass
                continue

            if method in ("DELETE", "POST", "PUT", "PATCH"):
                try:
                    http_interface.clear_body()
                    resp = http_interface.send_custom(method, test_path)
                except Exception:
                    resp = None

                if resp is None or resp.status_code == 404:
                    alt_id = None
                    try:
                        for e2 in api_client.endpoints:
                            if e2.method and e2.method.upper() == "GET" and e2.path and e2.path.rstrip("/").endswith("/users"):
                                try:
                                    discovered = http_interface.send_custom("GET", e2.path)
                                    if discovered and discovered.status_code == 200:
                                        try:
                                            body = discovered.json()
                                        except Exception:
                                            body = None
                                        if isinstance(body, list) and len(body) > 0:
                                            first = body[0]
                                            if isinstance(first, dict):
                                                for k in ("id", "user_id", "userId", "uid"):
                                                    if k in first:
                                                        alt_id = str(first[k])
                                                        break
                                                if alt_id is None:
                                                    for v in first.values():
                                                        if isinstance(v, int):
                                                            alt_id = str(v)
                                                            break
                                            elif isinstance(first, int):
                                                alt_id = str(first)
                                    if alt_id:
                                        break
                                except Exception:
                                    continue
                    except Exception:
                        alt_id = None

                    if alt_id:
                        retry_path = re.sub(r"\{[^}]*\}", alt_id, path)
                        try:
                            resp = http_interface.send_custom(method, retry_path)
                            test_path = retry_path
                        except Exception:
                            pass

                if resp is None:
                    continue

                try:
                    if resp.status_code in (200, 201, 204):
                        body_text = "<no-body>"
                        try:
                            body_text = resp.json()
                        except Exception:
                            try:
                                body_text = resp.text
                            except Exception:
                                pass

                        scan_evidence = f"Method: {method}\nPath: {test_path}\nStatus: {resp.status_code}\nResponse: {body_text}"
                        sr = ScanResult(
                            5,
                            OWASP_FLAGS.BFLA.value,
                            endpoint,
                            self.risk_level,
                            10,
                            "Privileged function executed without proper function/role-level authorization.",
                            "Enforce role/permission checks for privileged functions and ensure least privilege controls.",
                            scan_evidence,
                            "Function executed without proper authorization",
                            {"status": resp.status_code, "response": body_text}
                        )
                        results.append(sr)
                except Exception:
                    pass
                finally:
                    http_interface.clear_body()

        return results


# class UABF_Scan(VulnerabilityTest):
#     def __init__(self):
#         super().__init__()
#         self.name = OWASP_FLAGS.UABF
#         self.description = "Tests for unrestricted access to sensitive business flows"
#         self.risk_level = "Medium"
#         self.category = "Business Logic"
#         self.endpoints = []

#     def _set_flag(self, api_client):
#         print("Setting flags for UABF")
#         try:
#             for endpoint in api_client.endpoints:
#                 # Check if endpoint is sensitive
#                 if "sensitive" in endpoint.description.lower() or "business" in endpoint.description.lower():
#                     endpoint.add_flag(OWASP_FLAGS.UABF)
#                     self.endpoints.append(endpoint)
#             self.flags_set = True
#             return ENDPOINT_FLAGS.SUCCESS
#         except Exception as e:
#             print(f"[ERROR] Failed to set UABF flag: {e}")
#             return ENDPOINT_FLAGS.FAILED

#     def run_test(self, api_client):
#         if self._set_flag(api_client) != ENDPOINT_FLAGS.SUCCESS:
#             return []
#         results = []
#         # Test unrestricted access
#         for endpoint in self.endpoints:
#             if OWASP_FLAGS.UABF not in endpoint.get_flags():
#                 continue
#             # Send request without authentication
#             http_interface = HTTPInterface(api_client.get_url())
#             response = http_interface.send_custom(endpoint.method, endpoint.path)
#             if response.status_code == 200:
#                 scan_evidence = f"Method: {endpoint.method}\nPath: {endpoint.path}\nStatus: {response.status_code}"
#                 sr = ScanResult(
#                     6,
#                     OWASP_FLAGS.UABF.value,
#                     endpoint,
#                     self.risk_level,
#                     8,
#                     "Unrestricted access to sensitive business flows: endpoint accessible without authentication",
#                     "Implement proper authentication and authorization",
#                     scan_evidence,
#                     "Unrestricted access",
#                     {}
#                 )
#                 results.append(sr)
#         return results

# class SEC_MISC_Scan(VulnerabilityTest):
#     def __init__(self):
#         super().__init__()
#         self.name = OWASP_FLAGS.SEC_MISC
#         self.description = "Tests for security misconfiguration"
#         self.risk_level = "Medium"
#         self.category = "Configuration"
#         self.endpoints = []

#     def _set_flag(self, api_client):
#         print("Setting flags for SEC_MISC")
#         try:
#             for endpoint in api_client.endpoints:
#                 # Check if endpoint has security misconfiguration
#                 if "security" in endpoint.description.lower() or "misconfiguration" in endpoint.description.lower():
#                     endpoint.add_flag(OWASP_FLAGS.SEC_MISC)
#                     self.endpoints.append(endpoint)
#             self.flags_set = True
#             return ENDPOINT_FLAGS.SUCCESS
#         except Exception as e:
#             print(f"[ERROR] Failed to set SEC_MISC flag: {e}")
#             return ENDPOINT_FLAGS.FAILED

#     def run_test(self, api_client):
#         if self._set_flag(api_client) != ENDPOINT_FLAGS.SUCCESS:
#             return []
#         results = []
#         # Test security misconfiguration
#         for endpoint in self.endpoints:
#             if OWASP_FLAGS.SEC_MISC not in endpoint.get_flags():
#                 continue
#             # Check for security headers
#             http_interface = HTTPInterface(api_client.get_url())
#             response = http_interface.send_custom(endpoint.method, endpoint.path)
#             if "Content-Security-Policy" not in response.headers:
#                 scan_evidence = f"Method: {endpoint.method}\nPath: {endpoint.path}\nHeader: Content-Security-Policy not found"
#                 sr = ScanResult(
#                     8,
#                     OWASP_FLAGS.SEC_MISC.value,
#                     endpoint,
#                     self.risk_level,
#                     6,
#                     "Security misconfiguration: Content-Security-Policy header not found",
#                     "Implement Content-Security-Policy header",
#                     scan_evidence,
#                     "Security misconfiguration",
#                     {}
#                 )
#                 results.append(sr)
#         return results





class SSRF_Scan(VulnerabilityTest):
    def __init__(self):
        super().__init__()
        self.name = OWASP_FLAGS.SSRF
        self.description = "Tests for server side request forgery vulnerabilities"
        self.risk_level = "High"
        self.category = "Input Validation"
        self.endpoints = []

    def _set_flag(self, api_client):
        print("Setting flags for SSRF")
        self.endpoints = []
        keywords = ["ssrf", "fetch", "webhook", "proxy"]
        for endpoint in api_client.endpoints:
            path = (endpoint.path or "").lower()
            summary = (endpoint.summary or "").lower()
            desc = (endpoint.description or "").lower()
            combined = " ".join([path, summary, desc])
            if any(k in combined for k in keywords):
                if OWASP_FLAGS.SSRF not in endpoint.get_flags():
                    endpoint.add_flag(OWASP_FLAGS.SSRF)
                self.endpoints.append(endpoint)
        self.flags_set = True
        return ENDPOINT_FLAGS.SUCCESS if self.endpoints else ENDPOINT_FLAGS.FAILED

    def run_test(self, api_client):
        # Deprecated
        # if self._set_flag(api_client) != ENDPOINT_FLAGS.SUCCESS:
        #     return []

        base_url = api_client.get_url()
        http_interface = HTTPInterface(base_url)

        try:
            auth_hdr = api_client.get_auth_header()
            http_interface.add_header(auth_hdr)
        except Exception:
            pass

        results = []

        # payloads targeting internal services / metadata APIs
        ssrf_payloads = [
            "http://127.0.0.1",
            "http://localhost",
            "http://169.254.169.254/latest/meta-data/",
        ]

        for endpoint in self.endpoints:
            if OWASP_FLAGS.SSRF not in endpoint.get_flags():
                continue

            if OWASP_FLAGS.SKIP in endpoint.get_flags():
                continue

            method = (endpoint.method or "").upper()
            path = endpoint.path or ""

            # Detect query param style SSRF
            if method == "GET":
                for payload in ssrf_payloads:
                    if "{path}" in path:
                        test_path = path.replace("{path}", payload)
                    else:
                        # append ?url= or ?callback_url= depending on param
                        if "{" not in path:
                            sep = "&" if "?" in path else "?"
                            test_path = f"{path}{sep}url={payload}"
                        else:
                            continue

                    resp = http_interface.send_custom("GET", test_path)
                    if resp and resp.status_code < 500 and payload in resp.text:
                        sr = ScanResult(
                            7,
                            OWASP_FLAGS.SSRF.value,
                            endpoint,
                            self.risk_level,
                            9,
                            "Endpoint appears vulnerable to SSRF.",
                            "Validate and restrict outgoing requests to allowed hosts.",
                            f"Sent {payload}, received status {resp.status_code}",
                            "SSRF confirmed",
                            {"payload": payload, "status": resp.status_code}
                        )
                        results.append(sr)

            elif method == "POST":
                for payload in ssrf_payloads:
                    body = {}
                    if "webhook" in path.lower():
                        body = {"callback_url": payload, "data": {"test": "123"}}
                    else:
                        body = {"url": payload}

                    resp = http_interface.send_custom("POST", path, json=body)
                    if resp and resp.status_code < 500 and payload in resp.text:
                        sr = ScanResult(
                            7,
                            OWASP_FLAGS.SSRF.value,
                            endpoint,
                            self.risk_level,
                            9,
                            "Endpoint appears vulnerable to SSRF.",
                            "Validate and restrict outgoing requests to allowed hosts.",
                            f"Sent {payload}, received status {resp.status_code}",
                            "SSRF confirmed",
                            {"payload": payload, "status": resp.status_code}
                        )
                        results.append(sr)

        return results




class SEC_MISC_Scan(VulnerabilityTest):
    def __init__(self):
        super().__init__()
        self.name = OWASP_FLAGS.SEC_MISC
        self.description = "Tests for security misconfigurations"
        self.risk_level = "Medium"
        self.category = "Configuration"
        self.endpoints = []

    def _set_flag(self, api_client):
        print("do something")
    
    def run_test(self, api_client):
        self._set_flag(api_client)
        print("do something")




class IIM_Scan(VulnerabilityTest):
    def __init__(self):
        super().__init__()
        self.name = OWASP_FLAGS.IIM
        self.description = "Tests for improper inventory management issues"
        self.risk_level = "Low"
        self.category = "Asset Management"
        self.endpoints = []

    def _set_flag(self, api_client):
        print("Setting flags for IIM")
        """
        Heuristics to flag endpoints that are likely IIM candidates:
            - versioned/legacy endpoints (e.g. /v1/, /beta/, /deprecated/, /experimental/)
            - presence of multiple versions for same resource (e.g. /v1/... and /v2/...)
            - path/summary/description contain 'beta', 'deprecated', 'experimental', 'legacy', 'v1'
        """
        try:
            self.endpoints = []

            keywords = ["v1/", "/beta", "beta", "deprecated", "experimental", "legacy", "old"]
            # build a quick mapping of normalized resource -> versions seen
            version_map = {}
            for ep in api_client.endpoints:
                p = (ep.path or "").lower()
                # try to extract a version token like /v1/ or /v2/
                m = re.search(r"/v(\d+)/", p)
                version = m.group(1) if m else None
                # normalize resource by removing version segment
                norm = re.sub(r"/v\d+/", "/", p) if version else p
                version_map.setdefault(norm, set())
                if version:
                    version_map[norm].add(version)

            for endpoint in api_client.endpoints:
                path = (endpoint.path or "").lower()
                summary = (endpoint.summary or "").lower()
                desc = (endpoint.description or "").lower()
                combined = " ".join([path, summary, desc])

                flagged = False

                # 1) explicit keywords
                if any(k in combined for k in keywords):
                    flagged = True

                # 2) version mismatch: e.g. /v1/... exists while /v2/... also exists for same resource
                norm = re.sub(r"/v\d+/", "/", path)
                versions = version_map.get(norm, set())
                if len(versions) > 1:
                    # if this endpoint is a non-latest version, flag it
                    flagged = True

                if flagged:
                    if OWASP_FLAGS.IIM not in endpoint.get_flags():
                        endpoint.add_flag(OWASP_FLAGS.IIM)
                    if endpoint not in self.endpoints:
                        self.endpoints.append(endpoint)

            self.flags_set = True
            return ENDPOINT_FLAGS.SUCCESS
        except Exception:
            return ENDPOINT_FLAGS.FAILED

    def run_test(self, api_client):
        """
        For each endpoint flagged as IIM candidate:
        - Probe the endpoint (GET by default) and inspect returned JSON for:
            * plaintext secrets/passwords in responses
            * 'auth_bypass' or similar flags
            * sensitive 'secret' / 'api_key' fields exposed
            * version fields indicating old versions
            * experimental/beta/deprecated indicators in response body
        - Return a list of ScanResult objects (empty if none).
        """

        # deprecated
        # if self._set_flag(api_client) != ENDPOINT_FLAGS.SUCCESS:
        #     return []

        base_url = api_client.get_url()
        http_interface = HTTPInterface(base_url)

        # best-effort auth header if available
        try:
            http_interface.add_header(api_client.get_auth_header())
        except Exception:
            pass

        results = []

        def _choose_replacement(ep):
            try:
                for p in ep.parameters or []:
                    pname = p.get("name", "").lower()
                    schema = p.get("schema", {}) or {}
                    if "id" in pname:
                        if schema.get("type") == "integer":
                            return "1"
                        else:
                            return "11111111-1111-1111-1111-111111111111"
            except Exception:
                pass
            return "1"

        sensitive_field_indicators = {"password", "secret", "auth_bypass", "api_key", "api_keys", "token"}

        for endpoint in self.endpoints:
            if OWASP_FLAGS.IIM not in endpoint.get_flags():
                continue

            if OWASP_FLAGS.SKIP in endpoint.get_flags():
                continue

            method = (endpoint.method or "GET").upper()
            path = endpoint.path or ""
            test_path = path
            if "{" in test_path:
                replacement = _choose_replacement(endpoint)
                test_path = re.sub(r"\{[^}]*\}", replacement, test_path)

            # perform the request
            try:
                resp = http_interface.send_custom(method, test_path)
            except Exception:
                resp = None

            if resp is None:
                continue

            # attempt to parse JSON body
            body = None
            try:
                body = resp.json()
            except Exception:
                body = None

            # analyze response for a variety of IIM indicators
            try:
                # 1) Old-version endpoints: check explicit 'version' in response
                if isinstance(body, dict):
                    ver = body.get("version")
                    if ver and isinstance(ver, (str, int)):
                        # flag if version looks like '1' or starts with '1.'
                        try:
                            ver_str = str(ver)
                            if ver_str.startswith("1"):
                                scan_evidence = f"Method: {method}\nPath: {test_path}\nReturned version: {ver_str}"
                                sr = ScanResult(
                                    9,
                                    OWASP_FLAGS.IIM.value,
                                    endpoint,
                                    self.risk_level,
                                    5,
                                    "Older API version accessible (improper version management).",
                                    "Deprecate and remove old API versions or gate them behind proper controls.",
                                    scan_evidence,
                                    "Old API version exposed",
                                    {"version": ver_str}
                                )
                                results.append(sr)
                        except Exception:
                            pass

                    # 2) Deprecated / experimental indicator in body
                    lowered = " ".join([str(body.get(k)).lower() for k in body.keys()]) if body else ""
                    if any(k in lowered for k in ["deprecated", "experimental", "beta", "warning"]):
                        scan_evidence = f"Method: {method}\nPath: {test_path}\nResponse contained deprecated/experimental indicators"
                        sr = ScanResult(
                            9,
                            OWASP_FLAGS.IIM.value,
                            endpoint,
                            self.risk_level,
                            5,
                            "Deprecated/experimental endpoint accessible in production.",
                            "Remove experimental endpoints from production or restrict access.",
                            scan_evidence,
                            "Experimental/deprecated endpoint exposed",
                            {"response_keys": list(body.keys())}
                        )
                        results.append(sr)

                    # 3) Exposed secrets / plaintext passwords or auth bypass flags
                    # scan top-level and one-level-deep keys/values
                    found_secrets = []
                    def _scan_obj(obj):
                        if not isinstance(obj, dict):
                            return
                        for k, v in obj.items():
                            kl = k.lower()
                            if any(sf in kl for sf in sensitive_field_indicators):
                                found_secrets.append(k)
                            # values that look like secrets
                            if isinstance(v, str) and any(ind in v.lower() for ind in sensitive_field_indicators):
                                if k not in found_secrets:
                                    found_secrets.append(k)

                    _scan_obj(body)
                    for v in body.values() if isinstance(body, dict) else []:
                        if isinstance(v, dict):
                            _scan_obj(v)

                    if found_secrets:
                        scan_evidence = f"Method: {method}\nPath: {test_path}\nExposed fields: {found_secrets}"
                        sr = ScanResult(
                            9,
                            OWASP_FLAGS.IIM.value,
                            endpoint,
                            self.risk_level,
                            6,
                            "Endpoint exposes sensitive inventory or legacy test data (secrets/passwords).",
                            "Remove secrets and deprecated test data from production endpoints; enforce inventory hygiene.",
                            scan_evidence,
                            "Exposed secrets / legacy data",
                            {"exposed_fields": found_secrets}
                        )
                        results.append(sr)

                # 4) If response is a list, check first few items for password/secret fields
                if isinstance(body, list) and len(body) > 0:
                    sample = body[:5]
                    found = []
                    for item in sample:
                        if isinstance(item, dict):
                            for k in item.keys():
                                if any(sf in k.lower() for sf in sensitive_field_indicators):
                                    if k not in found:
                                        found.append(k)
                            for v in item.values():
                                if isinstance(v, str) and any(ind in v.lower() for ind in sensitive_field_indicators):
                                    # include a synthetic key to indicate value leak
                                    if "value_leak" not in found:
                                        found.append("value_leak")
                    if found:
                        scan_evidence = f"Method: {method}\nPath: {test_path}\nList items exposed fields: {found}"
                        sr = ScanResult(
                            9,
                            OWASP_FLAGS.IIM.value,
                            endpoint,
                            self.risk_level,
                            6,
                            "Endpoint returns legacy inventory or test data containing secrets.",
                            "Remove legacy endpoints and scrub sensitive test data from responses.",
                            scan_evidence,
                            "List response contains secrets/legacy data",
                            {"sample_exposed": found}
                        )
                        results.append(sr)

            except Exception:
                # keep scanning other endpoints even if analysis of one fails
                pass

        return results



# class UCAPI_Scan(VulnerabilityTest):
#     def __init__(self):
#         super().__init__()
#         self.name = OWASP_FLAGS.UCAPI
#         self.description = "Tests for unsafe consumption of APIs"
#         self.risk_level = "Medium"
#         self.category = "API Security"
#         self.endpoints = []

#     def _set_flag(self, api_client):
#         print("Setting flags for UCAPI")
#         try:
#             for endpoint in api_client.endpoints:
#                 # Check if endpoint consumes APIs
#                 if "api" in endpoint.description.lower() or "consume" in endpoint.description.lower():
#                     endpoint.add_flag(OWASP_FLAGS.UCAPI)
#                     self.endpoints.append(endpoint)
#             self.flags_set = True
#             return ENDPOINT_FLAGS.SUCCESS
#         except Exception as e:
#             print(f"[ERROR] Failed to set UCAPI flag: {e}")
#             return ENDPOINT_FLAGS.FAILED

#     def run_test(self, api_client):
#         if self._set_flag(api_client) != ENDPOINT_FLAGS.SUCCESS:
#             return []
#         results = []
#         # Test API consumption
#         for endpoint in self.endpoints:
#             if OWASP_FLAGS.UCAPI not in endpoint.get_flags():
#                 continue
#             # Send request with malicious API call
#             http_interface = HTTPInterface(api_client.get_url())
#             response = http_interface.send_custom(endpoint.method, endpoint.path)
#             if response.status_code == 200:
#                 scan_evidence = f"Method: {endpoint.method}\nPath: {endpoint.path}\nStatus: {response.status_code}"
#                 sr = ScanResult(
#                     10,
#                     OWASP_FLAGS.UCAPI.value,
#                     endpoint,
#                     self.risk_level,
#                     8,
#                     "Unsafe consumption of APIs: endpoint consumes malicious API",
#                     "Validate and restrict API calls",
#                     scan_evidence,
#                     "API consumption vulnerability",
#                     {}
#                 )
#                 results.append(sr)
#         return results

