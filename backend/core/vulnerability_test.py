# defines the VulnerabilityTest as well as specific tests
from enum import Enum
import re
import itertools
from core.scan_result import ScanResult
from core.http_interface import HTTPInterface
from core.owasp_flags import OWASP_FLAGS, ENDPOINT_FLAGS

# FIX: Updated imports to reflect the new 'vulnerability_tests' subdirectory
from core.vulnerability_tests.BOLA import test_id_tampering, test_producer_consumer_access
from core.vulnerability_tests.BKEN_AUTH import test_auth_mechanisms, test_jwt_vulnerabilities
from core.vulnerability_tests.BOPLA import test_property_level_issues, test_mass_assignment_stateful
from core.vulnerability_tests.URC import test_resource_consumption, test_rate_limiting_concurrent, test_large_payload, test_pagination_abuse
from core.vulnerability_tests.BFLA import test_function_level_auth, test_bfla_access_control_matrix
from core.vulnerability_tests.UABF import test_business_flows, test_for_abuse_controls
from core.vulnerability_tests.SSRF import test_ssrf, test_ssrf_oast
from core.vulnerability_tests.SEC_MISC import test_misconfig, test_security_misconfigurations
from core.vulnerability_tests.IIM import test_inventory, test_for_zombie_apis
from core.vulnerability_tests.UCAPI import test_unsafe_consumption, test_unsafe_consumption_with_mocking

class VulnerabilityTest:
    def __init__(self):
        self.name = ""
        self.description = ""
        self.risk_level = ""
        self.category = ""
        self.stats = {
            'total_endpoints': 0,
            'vulnerable_endpoints': 0,
            'high_risk': 0,
            'medium_risk': 0,
            'low_risk': 0
        }
        self.flags_set = False

    def update_flags(self):
        self.flags_set = False

    def run_test(self, api_client):
        print("do something")

    def _set_flag(self, api_client):
        # Helper function, call in run_test
        # Set's the appropriate flags for each endpoint in the api_client
        # Make sure to update flags_set to true at the end of each _set_flag
        print("do something")


class BOLA_Scan(VulnerabilityTest):
    def __init__(self):
        super().__init__()
        self.name = OWASP_FLAGS.BOLA
        self.description = "Tests for authorization flaws allowing access to other users' objects."
        self.risk_level = "High"
        self.category = "Authorization"
        self.producer_endpoints = []
        self.consumer_endpoints = []
        self.generic_endpoints = [] # For fallback test

    def _set_flag(self, api_client):
        print("Setting flags for BOLA")
        
        # Patterns to identify paths with object identifiers
        object_id_pattern = r'\{[a-zA-Z]*[Ii]d\}|\{[a-zA-Z]*_id\}'

        self.sensitive_id_patterns = [
            r'\{userId\}', r'\{user_id\}', r'\{accountId\}', r'\{account_id\}', r'\{orderId\}',
            r'\{order_id\}', r'\{documentId\}', r'\{document_id\}', r'\{fileId\}', r'\{file_id\}',
            r'\{resourceId\}', r'\{resource_id\}', r'\{invoiceId\}', r'\{invoice_id\}',
            r'\{sessionId\}', r'\{session_id\}', r'\{id\}', r'\{userId\}', r'\{user_id\}',
        ]

        try:
            for endpoint in api_client.endpoints:
                # A "producer" is an endpoint that creates an object, typically POST on a collection.
                # e.g., POST /api/v1/users
                if endpoint.method.upper() == "POST" and '{' not in endpoint.path:
                    self.producer_endpoints.append(endpoint)
                    endpoint.add_flag(OWASP_FLAGS.BOLA) # Flag for visibility

                # A "consumer" is an endpoint that acts on a specific object via an ID in the path.
                # e.g., GET /api/v1/users/{userId}
                elif re.search(object_id_pattern, endpoint.path) and endpoint.method.upper() in ["GET", "PUT", "PATCH", "DELETE"]:
                     if endpoint.check_auth():
                        self.consumer_endpoints.append(endpoint)
                        self.generic_endpoints.append(endpoint) # Also add to generic list for fallback
                        endpoint.add_flag(OWASP_FLAGS.BOLA)

            for endpoint in api_client.endpoints:
                path = endpoint.path
                if any(re.search(pattern, path) for pattern in self.object_id_patterns):
                    if endpoint.check_auth():
                        if any(re.search(pattern, path) for pattern in self.sensitive_id_patterns):
                            endpoint.add_flag(OWASP_FLAGS.BOLA)
                            self.endpoints.append(endpoint)

            self.flags_set = True
            print(f"BOLA Flags Set: {len(self.producer_endpoints)} producers, {len(self.consumer_endpoints)} consumers identified.")
            return ENDPOINT_FLAGS.SUCCESS
        except Exception as e:
            print(f"[ERROR] Failed to set BOLA flag: {e}")
            return ENDPOINT_FLAGS.FAILED

    def run_test(self, api_client):
        print("Starting BOLA Test")
        all_results = []

        # 1. Run the advanced producer-consumer test if a second token is available
        producer_consumer_results = test_producer_consumer_access(
            api_client, self.producer_endpoints, self.consumer_endpoints, self.risk_level
        )
        all_results.extend(producer_consumer_results)
        
        print("Running ID tampering test...")
        id_tampering_results = test_id_tampering(api_client, self.generic_endpoints, self.risk_level)
        all_results.extend(id_tampering_results)

        return all_results



class BKEN_AUTH_Scan(VulnerabilityTest):
    def __init__(self):
        super().__init__()
        self.name = OWASP_FLAGS.BKEN_AUTH
        self.description = "Tests for authentication mechanism weaknesses"
        self.risk_level = "High"
        self.category = "Authentication"
        self.endpoints = []

    def _set_flag(self, api_client):
        print("Setting flags for BKEN_AUTH")
        try:
            for endpoint in api_client.endpoints:
                if endpoint.check_auth():
                    endpoint.add_flag(OWASP_FLAGS.BKEN_AUTH)
                    self.endpoints.append(endpoint)
            self.flags_set = True
            return ENDPOINT_FLAGS.SUCCESS
        except Exception as e:
            print(f"[ERROR] Failed to set BKEN_AUTH flag: {e}")
            return ENDPOINT_FLAGS.FAILED

    def run_test(self, api_client):
        print("Starting Broken Authentication Test")
        all_results = []
        
        unauthenticated_results = test_auth_mechanisms(api_client, self.endpoints, self.risk_level)
        all_results.extend(unauthenticated_results)

        if api_client.auth_token:
            jwt_results = test_jwt_vulnerabilities(api_client, self.endpoints, self.risk_level)
            all_results.extend(jwt_results)
        
        return all_results


class BOPLA_Scan(VulnerabilityTest):
    def __init__(self):
        super().__init__()
        self.name = OWASP_FLAGS.BOPLA
        self.description = "Tests for object property level authorization issues"
        self.risk_level = "High"
        self.category = "Authorization"
        self.endpoints = []
        self.resource_groups = {} # For new stateful test

    def _set_flag(self, api_client):
        print("Setting flags for BOPLA")
        sensitive_props = [
            "ssn", "social", "password", "pass", "role", "is_admin", "admin",
            "balance", "internal", "profit_margin", "internal_notes", "credit_card",
            "card_number", "secret", "token", "account", "owner_id", "ssn_number"
        ]
        resource_keywords = ["user", "account", "invoice", "order", "customer", "profile"]
        try:
            all_flagged_endpoints = [] # Use a temp list to add to self.endpoints at the end
            for endpoint in api_client.endpoints:
                marked = False
                method = (endpoint.method or "").upper()
                path = endpoint.path or ""
                summary = (endpoint.summary or "") + " " + (endpoint.description or "")
                tags = " ".join(endpoint.tags or [])
                rb = endpoint.request_body or {}
                if isinstance(rb, dict) and rb.get("content"):
                    for _, content_schema in rb.get("content", {}).items():
                        schema = content_schema.get("schema", {}) if isinstance(content_schema, dict) else {}
                        props = schema.get("properties", {}) if isinstance(schema.get("properties", {}), dict) else {}
                        for prop in props.keys():
                            if any(sp in prop.lower() for sp in sensitive_props):
                                all_flagged_endpoints.append(endpoint)
                                marked = True; break
                        if marked: break
                        if schema.get("additionalProperties") is True:
                            all_flagged_endpoints.append(endpoint)
                            marked = True; break
                    if not marked and method in ("PATCH", "PUT", "POST"):
                        all_flagged_endpoints.append(endpoint)
                        marked = True
                if marked: continue
                responses = endpoint.responses or {}
                if isinstance(responses, dict):
                    for resp_info in responses.values():
                        if not isinstance(resp_info, dict): continue
                        contents = resp_info.get("content", {}) if isinstance(resp_info.get("content", {}), dict) else {}
                        for _, content_schema in contents.items():
                            schema = content_schema.get("schema", {}) if isinstance(content_schema, dict) else {}
                            props = schema.get("properties", {}) if isinstance(schema.get("properties", {}), dict) else {}
                            for prop in props.keys():
                                if any(sp in prop.lower() for sp in sensitive_props):
                                    all_flagged_endpoints.append(endpoint)
                                    marked = True; break
                            if marked: break
                            example = content_schema.get("example")
                            if isinstance(example, dict):
                                for k in example.keys():
                                    if any(sp in k.lower() for sp in sensitive_props):
                                        all_flagged_endpoints.append(endpoint)
                                        marked = True; break
                            if marked: break
                        if marked: break
                if marked: continue
                lowered = (path + " " + summary + " " + tags).lower()
                if any(k in lowered for k in resource_keywords) or any(sp in lowered for sp in sensitive_props):
                    if method in ("GET", "PATCH", "PUT", "POST"):
                        all_flagged_endpoints.append(endpoint)
                        continue
                for p in endpoint.parameters or []:
                    pname = p.get("name", "").lower()
                    if any(sp in pname for sp in sensitive_props):
                        all_flagged_endpoints.append(endpoint)
                        break
            
            # Add all unique flagged endpoints to the main list
            unique_endpoints = {ep.id: ep for ep in all_flagged_endpoints}.values()
            self.endpoints.extend(unique_endpoints)
            for ep in self.endpoints:
                ep.add_flag(OWASP_FLAGS.BOPLA)

            # --- New, additional logic to group endpoints for stateful testing ---
            for endpoint in api_client.endpoints:
                base_path = re.sub(r'/\{[^}]+\}$', '', endpoint.path)
                if base_path not in self.resource_groups:
                    self.resource_groups[base_path] = {}
                method = endpoint.method.upper()
                if method == 'GET' and '{' in endpoint.path: self.resource_groups[base_path][method] = endpoint
                elif method == 'POST' and '{' not in endpoint.path: self.resource_groups[base_path][method] = endpoint
                elif method in ['PUT', 'PATCH']: self.resource_groups[base_path][method] = endpoint

            self.flags_set = True
            return ENDPOINT_FLAGS.SUCCESS
        except Exception as e:
            print(f"[ERROR] Failed to set BOPLA flag: {e}")
            return ENDPOINT_FLAGS.FAILED

    def run_test(self, api_client):
        print("Starting BOPLA Test Suite")
        all_results = []
        
        # 1. Run the original, simple test for demonstration and basic checks
        print("[*] Running original BOPLA test (response reflection)...")
        original_results = test_property_level_issues(api_client, self.endpoints, self.risk_level)
        all_results.extend(original_results)

        # 2. Run the new, advanced stateful test for more accurate findings
        print("[*] Running advanced stateful BOPLA test...")
        stateful_results = test_mass_assignment_stateful(api_client, self.resource_groups, self.risk_level)
        all_results.extend(stateful_results)
        
        return all_results

class URC_Scan(VulnerabilityTest):
    def __init__(self):
        super().__init__()
        self.name = OWASP_FLAGS.URC
        self.description = "Tests for unrestricted resource consumption vulnerabilities"
        self.risk_level = "Medium"
        self.category = "Resource Management"
        self.endpoints_for_ratelimit = []
        self.endpoints_for_large_payload = []
        self.endpoints_for_pagination = [] # Stores tuples of (endpoint, param_name)

    def _set_flag(self, api_client):
        print("Setting flags for URC")
        # --- ADDING new flagging logic without touching the original ---
        pagination_params = ['limit', 'size', 'page', 'offset', 'max']
        try:
            for endpoint in api_client.endpoints:
                # Any endpoint can be tested for rate limiting
                self.endpoints_for_ratelimit.append(endpoint)
                endpoint.add_flag(OWASP_FLAGS.URC)

                # Original logic: Flag endpoints that accept data for large payload tests
                if endpoint.method.upper() in ["POST", "PUT", "PATCH"]:
                    self.endpoints_for_large_payload.append(endpoint)

                # New logic: Flag GET endpoints with pagination parameters
                if endpoint.method.upper() == "GET":
                    for param in endpoint.parameters:
                        param_name = param.get("name", "").lower()
                        if param_name in pagination_params:
                            self.endpoints_for_pagination.append((endpoint, param.get("name")))
                            # No need to flag again if already flagged
                            if OWASP_FLAGS.URC not in endpoint.get_flags():
                                endpoint.add_flag(OWASP_FLAGS.URC)
                            break # Move to next endpoint once one pagination param is found
                            
            self.flags_set = True
            return ENDPOINT_FLAGS.SUCCESS
        except Exception as e:
            print(f"[ERROR] Failed to set URC flag: {e}")
            return ENDPOINT_FLAGS.FAILED

    def run_test(self, api_client):
        print("Starting Unrestricted Resource Consumption Test Suite")
        all_results = []
        
        print("[*] Running original sequential rate limit test...")
        original_results = test_resource_consumption(api_client, self.endpoints_for_ratelimit, self.risk_level)
        all_results.extend(original_results)

        print("[*] Running advanced concurrent rate limit test...")
        concurrent_results = test_rate_limiting_concurrent(api_client, self.endpoints_for_ratelimit, self.risk_level)
        all_results.extend(concurrent_results)

        print("[*] Running large payload submission test...")
        large_payload_results = test_large_payload(api_client, self.endpoints_for_large_payload, self.risk_level)
        all_results.extend(large_payload_results)
        
        print("[*] Running pagination abuse test...")
        pagination_results = test_pagination_abuse(api_client, self.endpoints_for_pagination, self.risk_level)
        all_results.extend(pagination_results)
        
        return all_results

class BFLA_Scan(VulnerabilityTest):
    def __init__(self):
        super().__init__()
        self.name = OWASP_FLAGS.BFLA
        self.description = "Tests for function level authorization issues"
        self.risk_level = "High"
        self.category = "Authorization"
        self.admin_endpoints = [] # Endpoints specifically flagged as admin/sensitive

    def _set_flag(self, api_client):
        # This function preserves the original flagging logic to identify sensitive endpoints.
        print("Setting flags for BFLA")
        try:
            keywords_admin = ["admin", "/admin/", "promote", "internal", "delete user", "delete-user", "delete_user"]
            
            for endpoint in api_client.endpoints:
                flag_as_admin = False
                path = (endpoint.path or "").lower()
                summary = (endpoint.summary or "").lower()
                desc = (endpoint.description or "").lower()
                combined = " ".join([path, summary, desc])

                if any(k in combined for k in keywords_admin):
                    flag_as_admin = True
                
                for t in endpoint.tags or []:
                    if isinstance(t, str) and ("admin" in t.lower() or "internal" in t.lower()):
                        flag_as_admin = True
                        break
                
                if flag_as_admin:
                    endpoint.add_flag(OWASP_FLAGS.BFLA)
                    if endpoint not in self.admin_endpoints:
                        self.admin_endpoints.append(endpoint)
                        
            self.flags_set = True
            print(f"[*] BFLA flagging complete. Found {len(self.admin_endpoints)} potential admin endpoints.")
            return ENDPOINT_FLAGS.SUCCESS
        except Exception as e:
            print(f"[ERROR] Failed to set BFLA flag: {e}")
            return ENDPOINT_FLAGS.FAILED

    def run_test(self, api_client):
        print("Starting Broken Function Level Authorization Test Suite")
        all_results = []
        
        # 1. Run the original, stateless test for demonstration
        print("[*] Running original BFLA stateless test...")
        original_results = test_function_level_auth(api_client, self.admin_endpoints, self.risk_level)
        all_results.extend(original_results)
        
        # 2. Run the new, more accurate Access Control Matrix test
        print("[*] Running advanced Access Control Matrix test...")
        matrix_results = test_bfla_access_control_matrix(api_client, self.admin_endpoints, self.risk_level)
        all_results.extend(matrix_results)

        return all_results

class UABF_Scan(VulnerabilityTest):
    def __init__(self):
        super().__init__()
        self.name = OWASP_FLAGS.UABF
        self.description = "Tests for unrestricted access to sensitive business flows"
        self.risk_level = "Medium"
        self.category = "Business Logic"
        self.endpoints = []

    def _set_flag(self, api_client):
        print("Setting flags for UABF")
        
        # New, more comprehensive list of keywords based on research 
        sensitive_keywords = [
            "purchase", "buy", "order", "book", "checkout", "redeem", 
            "coupon", "comment", "post", "review", "signup", "register",
            "vote", "submit", "claim"
        ]
        
        try:
            for endpoint in api_client.endpoints:
                # Original logic is preserved
                if "sensitive" in endpoint.description.lower() or "business" in endpoint.description.lower():
                    endpoint.add_flag(OWASP_FLAGS.UABF)
                    if endpoint not in self.endpoints:
                        self.endpoints.append(endpoint)
                    continue # Skip to next endpoint if already flagged
                
                # New, additional keyword logic
                endpoint_text = (endpoint.path + " " + endpoint.summary).lower()
                if any(keyword in endpoint_text for keyword in sensitive_keywords):
                    endpoint.add_flag(OWASP_FLAGS.UABF)
                    if endpoint not in self.endpoints:
                        self.endpoints.append(endpoint)

            self.flags_set = True
            print(f"[*] UABF flagging complete. Found {len(self.endpoints)} potentially sensitive business flows.")
            return ENDPOINT_FLAGS.SUCCESS
        except Exception as e:
            print(f"[ERROR] Failed to set UABF flag: {e}")
            return ENDPOINT_FLAGS.FAILED

    def run_test(self, api_client):
        print("Starting Unrestricted Access to Sensitive Business Flows Test Suite")
        all_results = []
        
        # 1. Run the original test for unauthenticated access
        print("[*] Running original unauthenticated access test for UABF...")
        original_results = test_business_flows(api_client, self.endpoints, self.risk_level)
        all_results.extend(original_results)
        
        # 2. Run the new, more relevant test for missing abuse controls
        print("[*] Running advanced abuse control test (rate limiting)...")
        abuse_control_results = test_for_abuse_controls(api_client, self.endpoints, self.risk_level)
        all_results.extend(abuse_control_results)
        
        return all_results

class SSRF_Scan(VulnerabilityTest):
    def __init__(self):
        super().__init__()
        self.name = OWASP_FLAGS.SSRF
        self.description = "Tests for server side request forgery vulnerabilities"
        self.risk_level = "High"
        self.category = "Input Validation"
        self.endpoints = []

    def _set_flag(self, api_client):
        # Adding more keywords to the original flagging logic
        print("Setting flags for SSRF")
        self.endpoints = []
        keywords = ["ssrf", "fetch", "webhook", "proxy", "import", "url", "uri", "link", "redirect"]
        for endpoint in api_client.endpoints:
            # Check endpoint path, summary, and description
            endpoint_text = (endpoint.path + " " + endpoint.summary + " " + endpoint.description).lower()
            if any(k in endpoint_text for k in keywords):
                if endpoint not in self.endpoints:
                    self.endpoints.append(endpoint)
                endpoint.add_flag(OWASP_FLAGS.SSRF)
                continue
            
            # Also check parameter names
            for param in endpoint.parameters:
                if any(k in param.get("name","").lower() for k in keywords):
                    if endpoint not in self.endpoints:
                        self.endpoints.append(endpoint)
                    endpoint.add_flag(OWASP_FLAGS.SSRF)
                    break
                    
        self.flags_set = True
        return ENDPOINT_FLAGS.SUCCESS

    def run_test(self, api_client):
        print("Starting Server-Side Request Forgery Test Suite")
        all_results = []

        # 1. Run the original, in-band SSRF test
        print("[*] Running original in-band SSRF test...")
        original_results = test_ssrf(api_client, self.endpoints, self.risk_level)
        all_results.extend(original_results)

        # 2. Run the new, advanced OAST-based test for Blind SSRF
        print("[*] Running advanced OAST-based Blind SSRF test...")
        oast_results = test_ssrf_oast(api_client, self.endpoints, self.risk_level)
        all_results.extend(oast_results)
        
        return all_results

class SEC_MISC_Scan(VulnerabilityTest):
    def __init__(self):
        super().__init__()
        self.name = OWASP_FLAGS.SEC_MISC
        self.description = "Tests for security misconfiguration"
        self.risk_level = "Medium"
        self.category = "Configuration"
        self.endpoints = []

    def _set_flag(self, api_client):
        print("Setting flags for SEC_MISC")
        try:
            # Security misconfigurations can affect any endpoint, so we test all of them.
            self.endpoints = api_client.endpoints
            for endpoint in self.endpoints:
                endpoint.add_flag(OWASP_FLAGS.SEC_MISC)
            self.flags_set = True
            print(f"[*] SEC_MISC flagging complete. All {len(self.endpoints)} endpoints will be checked.")
            return ENDPOINT_FLAGS.SUCCESS
        except Exception as e:
            print(f"[ERROR] Failed to set SEC_MISC flag: {e}")
            return ENDPOINT_FLAGS.FAILED

    def run_test(self, api_client):
        print("Starting Security Misconfiguration Test Suite")
        all_results = []
        
        # 1. Run the original, simple CSP header test for demonstration
        print("[*] Running original CSP header check...")
        original_results = test_misconfig(api_client, self.endpoints, self.risk_level)
        all_results.extend(original_results)
        
        # 2. Run the new, more comprehensive suite of misconfiguration tests
        print("[*] Running comprehensive misconfiguration checks...")
        comprehensive_results = test_security_misconfigurations(api_client, self.endpoints, self.risk_level)
        all_results.extend(comprehensive_results)
        
        return all_results

class IIM_Scan(VulnerabilityTest):
    def __init__(self):
        super().__init__()
        self.name = OWASP_FLAGS.IIM
        self.description = "Tests for improper inventory management issues"
        self.risk_level = "Low"
        self.category = "Asset Management"
        self.endpoints = []

    def _set_flag(self, api_client):
        # This logic correctly identifies versioned endpoints and is preserved.
        print("Setting flags for IIM")
        try:
            self.endpoints = []
            keywords = ["/v1/", "/beta", "beta", "deprecated", "experimental", "legacy", "old"]
            version_map = {}
            for ep in api_client.endpoints:
                p = (ep.path or "").lower()
                m = re.search(r"/v(\d+)/", p)
                version = m.group(1) if m else None
                norm = re.sub(r"/v\d+/", "/", p) if version else p
                version_map.setdefault(norm, set())
                if version:
                    version_map[norm].add(version)

            for endpoint in api_client.endpoints:
                path = (endpoint.path or "").lower()
                summary = (endpoint.summary or "").lower()
                desc = (endpoint.description or "").lower()
                combined = " ".join([path, summary, desc])
                flagged = False
                if any(k in combined for k in keywords):
                    flagged = True
                norm = re.sub(r"/v\d+/", "/", path)
                versions = version_map.get(norm, set())
                if len(versions) > 1:
                    flagged = True
                if flagged:
                    if OWASP_FLAGS.IIM not in endpoint.get_flags():
                        endpoint.add_flag(OWASP_FLAGS.IIM)
                    if endpoint not in self.endpoints:
                        self.endpoints.append(endpoint)
            self.flags_set = True
            return ENDPOINT_FLAGS.SUCCESS
        except Exception as e:
            print(f"[ERROR] Failed to set IIM flag: {e}")
            return ENDPOINT_FLAGS.FAILED

    def run_test(self, api_client):
        print("Starting Improper Inventory Management Test Suite")
        all_results = []
        
        # 1. Run the original test (more of a BOPLA check, but preserved as requested)
        print("[*] Running original legacy data exposure test...")
        original_results = test_inventory(api_client, self.endpoints, self.risk_level)
        all_results.extend(original_results)
        
        # 2. Run the new, more accurate test for Zombie API discovery
        # This test should run against ALL endpoints to be comprehensive, not just flagged ones.
        print("[*] Running new Zombie API discovery test...")
        zombie_api_results = test_for_zombie_apis(api_client, api_client.endpoints, self.risk_level)
        all_results.extend(zombie_api_results)
        
        return all_results

class UCAPI_Scan(VulnerabilityTest):
    def __init__(self):
        super().__init__()
        self.name = OWASP_FLAGS.UCAPI
        self.description = "Tests for unsafe consumption of APIs"
        self.risk_level = "Medium"
        self.category = "API Security"
        self.endpoints = []

    def _set_flag(self, api_client):
        print("Setting flags for UCAPI")
        
        # Keywords suggesting interaction with external services
        keywords = ["third-party", "external", "partner", "integration", "webhook", "proxy", "federated"]
        
        try:
            for endpoint in api_client.endpoints:
                # Original logic preserved
                if "api" in endpoint.description.lower() or "consume" in endpoint.description.lower():
                    if endpoint not in self.endpoints:
                        self.endpoints.append(endpoint)
                    endpoint.add_flag(OWASP_FLAGS.UCAPI)
                    continue
                
                # New, additional keyword logic
                endpoint_text = (endpoint.summary + " " + endpoint.description).lower()
                if any(keyword in endpoint_text for keyword in keywords):
                    if endpoint not in self.endpoints:
                        self.endpoints.append(endpoint)
                    endpoint.add_flag(OWASP_FLAGS.UCAPI)

            self.flags_set = True
            print(f"[*] UCAPI flagging complete. Found {len(self.endpoints)} endpoints that may consume external APIs.")
            return ENDPOINT_FLAGS.SUCCESS
        except Exception as e:
            print(f"[ERROR] Failed to set UCAPI flag: {e}")
            return ENDPOINT_FLAGS.FAILED

    def run_test(self, api_client):
        print("Starting Unsafe Consumption of APIs Test Suite")
        all_results = []

        # 1. Run the original, simple test
        print("[*] Running original basic consumption check...")
        original_results = test_unsafe_consumption(api_client, self.endpoints, self.risk_level)
        all_results.extend(original_results)

        # 2. Run the new, advanced test using API mocking
        print("[*] Running advanced test with API mocking...")
        print("[IMPORTANT] This test requires you to manually configure the application-under-test to use the mock server at http://localhost:8002 for its third-party API calls.")
        mocking_results = test_unsafe_consumption_with_mocking(api_client, self.endpoints, self.risk_level)
        all_results.extend(mocking_results)
        
        return all_results
