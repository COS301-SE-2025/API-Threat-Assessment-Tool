from core.scan_result import ScanResult
from core.http_interface import HTTPInterface
from core.owasp_flags import OWASP_FLAGS, ENDPOINT_FLAGS
import re
import itertools

def _extract_id(response_json):
    if not isinstance(response_json, dict):
        return None
    
    common_id_keys = ['id', '_id', 'uuid', 'guid']
    for key in common_id_keys:
        if key in response_json:
            return response_json[key]
    
    # Check for keys ending with 'Id' or '_id'
    for key, value in response_json.items():
        if key.lower().endswith('id'):
            return value
            
    # Check nested 'data' object
    if 'data' in response_json and isinstance(response_json['data'], dict):
        for key in common_id_keys:
            if key in response_json['data']:
                return response_json['data'][key]

    return None

def test_producer_consumer_access(api_client, producer_endpoints, consumer_endpoints, risk_level):
    """
    Tests for BOLA by creating a resource as User A and attempting to access it as User B.
    """
    results = []
    
    # Check if a secondary token is available for the test
    secondary_auth_header = api_client.get_secondary_auth_header()
    if not secondary_auth_header:
        print("[INFO] BOLA producer-consumer test skipped: Secondary auth token not provided.")
        return results

    url = api_client.get_url()
    http_producer = HTTPInterface(url)
    http_producer.add_header(api_client.get_auth_header()) # User A
    
    http_consumer = HTTPInterface(url)
    http_consumer.add_header(secondary_auth_header) # User B
    
    # Find logical pairs of producers and consumers
    # e.g., POST /users and GET /users/{id}
    for producer in producer_endpoints:
        base_path = producer.path.rstrip('/')
        
        # Create a basic payload if one is defined in the spec
        request_body_schema = producer.request_body.get("content", {}).get("application/json", {}).get("schema", {})
        payload = {"test_data": "created_by_scanner"} # Default payload
        if request_body_schema and 'properties' in request_body_schema:
             # This could be expanded to generate more realistic mock data
            payload = {prop: "string" for prop in request_body_schema['properties']}

        # Step 1: User A creates a resource
        response_a = http_producer.send_post(producer.path, body=payload)

        if response_a.status_code not in [200, 201, 202]:
            print(f"[WARN] Failed to create resource with User A at {producer.path}. Status: {response_a.status_code}")
            continue

        try:
            resource_id = _extract_id(response_a.json())
            if not resource_id:
                print(f"[WARN] Could not extract resource ID from response for {producer.path}")
                continue
        except Exception:
            print(f"[WARN] Response for {producer.path} was not valid JSON.")
            continue
            
        print(f"[*] User A created resource via {producer.path}, got ID: {resource_id}")

        # Step 2: User B attempts to access the resource
        for consumer in consumer_endpoints:
            # Match consumer to producer (e.g., path starts with the same base)
            consumer_path_template = consumer.path.rstrip('/')
            if not consumer_path_template.startswith(base_path) or '{' not in consumer_path_template:
                continue

            # Substitute the extracted ID into the consumer path
            test_path = re.sub(r"\{[^}]*id[^}]*\}", str(resource_id), consumer_path_template, flags=re.IGNORECASE)

            print(f"[*] User B attempting {consumer.method} on {test_path}")
            response_b = http_consumer.send_custom(consumer.method, test_path)

            # Step 3: Analyze the response from User B's attempt
            if 200 <= response_b.status_code < 300:
                scan_evidence = (
                    f"Flow: Producer-Consumer\n"
                    f"1. User A created resource via: POST {producer.path} -> ID: {resource_id}\n"
                    f"2. User B (attacker) accessed it via: {consumer.method} {test_path}\n"
                    f"3. Result: Successful status code ({response_b.status_code}) indicates BOLA."
                )
                sr = ScanResult(
                    owasp_category=OWASP_FLAGS.BOLA.value,
                    vulnerability_name="Broken Object Level Authorization",
                    endpoint=consumer,
                    severity=risk_level,
                    description="A user was able to access a resource belonging to another user, indicating a BOLA vulnerability.",
                    recommendation="Ensure that every request to access a data object includes an authorization check to confirm the requesting user has permission for that specific object.",
                    evidence=scan_evidence,
                    test_name="Cross-User Resource Access",
                    affected_params={"resource_id": resource_id}
                )
                results.append(sr)

    return results


def test_id_tampering(api_client, endpoints, risk_level):
    """
    Fallback BOLA test. Checks if predictable IDs for sensitive resources are accessible.
    Less accurate but useful when only one user token is available.
    """
    results = []
    url = api_client.get_url()
    http_interface = HTTPInterface(url)
    http_interface.add_header(api_client.get_auth_header())

    for endpoint in endpoints:
        if OWASP_FLAGS.BOLA not in endpoint.get_flags() or OWASP_FLAGS.SKIP in endpoint.get_flags():
            continue

        # Use a small, targeted list of IDs to check for common insecure direct object references
        candidate_ids = ["1", "100", "admin", "user1"]

        for test_id in candidate_ids:
            test_path = endpoint.path
            if "{" in test_path:
                test_path = re.sub(r"\{[^}]*id[^}]*\}", test_id, test_path, flags=re.IGNORECASE)
            
            params = {}
            for param in endpoint.parameters:
                if param.get("in") == "query" and "id" in param.get("name", "").lower():
                    params[param["name"]] = test_id
            
            # Avoid sending requests to the same path+params combination
            if not test_path.endswith(test_id) and not params:
                continue
                
            response = http_interface.send_custom(endpoint.method, test_path, params=params)

            # A 200 OK is a weak indicator, but suggests a potential IDOR if we can access a generic ID like '1'.
            if response.status_code == 200:
                scan_evidence = f"Method: {endpoint.method}\nPath: {test_path}\nParameters: {params}\nTest ID: {test_id}"
                sr = ScanResult(
                    1,
                    OWASP_FLAGS.BOLA.value,
                    endpoint,
                    risk_level,
                    10,
                    "Endpoint allows us to access data of other users by tampering with id's",
                    "Properly authenticate before returning data",
                    scan_evidence,
                    "Basic ID tampering",
                    params
                )
                results.append(sr)

    return results