# core/vulnerability_tests/IIM.py

from core.scan_result import ScanResult
from core.http_interface import HTTPInterface
from core.owasp_flags import OWASP_FLAGS
import re

# --- Original function, preserved for unit tests ---
def test_inventory(api_client, endpoints, risk_level):
    base_url = api_client.get_url()
    http_interface = HTTPInterface(base_url)
    try:
        http_interface.add_header(api_client.get_auth_header())
    except Exception:
        pass
    results = []
    sensitive_field_indicators = {"password", "secret", "auth_bypass", "api_key", "api_keys", "token"}

    def _choose_replacement(ep):
        try:
            for p in ep.parameters or []:
                pname = p.get("name", "").lower()
                schema = p.get("schema", {}) or {}
                if "id" in pname:
                    if schema.get("type") == "integer": return "1"
                    else: return "11111111-1111-1111-1111-111111111111"
        except Exception: pass
        return "1"

    for endpoint in endpoints:
        if OWASP_FLAGS.IIM not in endpoint.get_flags() or OWASP_FLAGS.SKIP in endpoint.get_flags():
            continue
        method = (endpoint.method or "GET").upper()
        test_path = endpoint.path or ""
        if "{" in test_path:
            test_path = re.sub(r"\{[^}]*\}", _choose_replacement(endpoint), test_path)
        try:
            resp = http_interface.send_custom(method, test_path)
        except Exception: resp = None
        if not resp: continue
        try:
            body = resp.json()
        except Exception: body = None
        if isinstance(body, dict):
            found_secrets = [k for k in body.keys() if any(sf in k.lower() for sf in sensitive_field_indicators)]
            if found_secrets:
                scan_evidence = f"Method: {method}\nPath: {test_path}\nExposed fields: {found_secrets}"
                sr = ScanResult(
                    owasp_category=OWASP_FLAGS.BOPLA.value, # Corrected category to BOPLA
                    vulnerability_name="9. Exposed Sensitive Data in Legacy Endpoint",
                    endpoint=endpoint, severity=risk_level,
                    description="Endpoint exposes sensitive inventory or legacy test data (secrets/passwords).",
                    recommendation="Remove secrets and deprecated test data from production endpoints; enforce inventory hygiene.",
                    evidence=scan_evidence, test_name="Exposed secrets / legacy data",
                    affected_params={"exposed_fields": found_secrets}
                )
                results.append(sr)
    return results


# --- New, discovery-focused test for Zombie APIs ---
def test_for_zombie_apis(api_client, endpoints, risk_level):
    """
    Searches for older, deprecated, or undocumented API versions by fuzzing path prefixes.
    """
    results = []
    base_url = api_client.get_url()
    http_interface = HTTPInterface(base_url)
    http_interface.add_header(api_client.get_auth_header())

    VERSION_PREFIXES = ['/v1', '/v2', '/v0', '/v1.1', '/beta', '/test', '/dev']
    
    # Use a set to avoid testing the same fuzzed path multiple times
    tested_paths = set()

    print("[*] Starting Zombie API discovery test...")
    for endpoint in endpoints:
        original_path = endpoint.path
        
        # Regex to find existing version prefixes like /v1, /v1.1, etc.
        version_match = re.search(r'(/(v[0-9.]+))', original_path)
        
        fuzz_paths = set()

        if version_match:
            # Path already has a version, e.g., /api/v2/users
            # Try replacing it with other versions
            existing_prefix = version_match.group(1)
            base_path = original_path.replace(existing_prefix, '')
            for prefix in VERSION_PREFIXES:
                if prefix != existing_prefix:
                    fuzz_paths.add(f"{prefix}{base_path}")
        else:
            # Path has no version, e.g., /api/users
            # Try prepending version prefixes
            for prefix in VERSION_PREFIXES:
                fuzz_paths.add(f"{prefix}{original_path}")

        for test_path in fuzz_paths:
            if test_path in tested_paths:
                continue
            tested_paths.add(test_path)
            
            # Use OPTIONS as a lightweight way to check for endpoint existence
            response = http_interface.send_custom("OPTIONS", test_path)
            
            # Any response other than 404 indicates the endpoint exists
            if response.status_code != 404:
                scan_evidence = (
                    f"Original documented path: {original_path}\n"
                    f"Fuzzed path: OPTIONS {test_path}\n"
                    f"Result: Received status code {response.status_code}, indicating the undocumented endpoint exists."
                )
                sr = ScanResult(
                    owasp_category=OWASP_FLAGS.IIM.value,
                    vulnerability_name="9. Zombie or Shadow API Detected",
                    endpoint=endpoint, # Report against the original endpoint for context
                    severity=risk_level,
                    description=f"An undocumented or deprecated API version was discovered at '{test_path}'. These 'zombie' endpoints are often unpatched and lack modern security controls.",
                    recommendation="Maintain a complete and accurate inventory of all deployed API versions. Decommission and block access to any versions that are no longer supported.",
                    evidence=scan_evidence,
                    test_name="API Version Fuzzing"
                )
                results.append(sr)
                print(f"[!!!] VULNERABILITY FOUND: Zombie/Shadow API at {test_path} (original: {original_path})")
                
    return results