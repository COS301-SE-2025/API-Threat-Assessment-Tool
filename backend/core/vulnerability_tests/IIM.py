# core/vulnerability_tests/IIM.py

from core.scan_result import ScanResult
from core.http_interface import HTTPInterface
from core.owasp_flags import OWASP_FLAGS
import re

# --- Original function, preserved for unit tests ---
def test_inventory(api_client, endpoints, risk_level):
    base_url = api_client.get_url()
    http_interface = HTTPInterface(base_url)

    # best-effort auth header if available
    try:
        http_interface.add_header(api_client.get_auth_header())
    except Exception:
        pass

    results = []

    def _choose_replacement(ep):
        try:
            for p in ep.parameters or []:
                pname = p.get("name", "").lower()
                schema = p.get("schema", {}) or {}
                if "id" in pname:
                    if schema.get("type") == "integer":
                        return "1"
                    else:
                        return "11111111-1111-1111-1111-111111111111"
        except Exception:
            pass
        return "1"

    sensitive_field_indicators = {"password", "secret", "auth_bypass", "api_key", "api_keys", "token"}

    for endpoint in endpoints:
        if OWASP_FLAGS.IIM not in endpoint.get_flags():
            continue

        if OWASP_FLAGS.SKIP in endpoint.get_flags():
            continue

        method = (endpoint.method or "GET").upper()
        path = endpoint.path or ""
        test_path = path
        if "{" in test_path:
            replacement = _choose_replacement(endpoint)
            test_path = re.sub(r"\{[^}]*\}", replacement, test_path)

        # perform the request
        try:
            resp = http_interface.send_custom(method, test_path)
        except Exception:
            resp = None

        if resp is None:
            continue

        # attempt to parse JSON body
        body = None
        try:
            body = resp.json()
        except Exception:
            body = None

        # analyze response for a variety of IIM indicators
        try:
            # 1) Old-version endpoints: check explicit 'version' in response
            if isinstance(body, dict):
                ver = body.get("version")
                if ver and isinstance(ver, (str, int)):
                    # flag if version looks like '1' or starts with '1.'
                    try:
                        ver_str = str(ver)
                        if ver_str.startswith("1"):
                            scan_evidence = f"Method: {method}\nPath: {test_path}\nReturned version: {ver_str}"
                            sr = ScanResult(
                                9,
                                OWASP_FLAGS.IIM.value,
                                endpoint,
                                risk_level,
                                5,
                                "Older API version accessible (improper version management).",
                                "Deprecate and remove old API versions or gate them behind proper controls.",
                                scan_evidence,
                                "Old API version exposed",
                                {"version": ver_str}
                            )
                            results.append(sr)
                    except Exception:
                        pass

                # 2) Deprecated / experimental indicator in body
                lowered = " ".join([str(body.get(k)).lower() for k in body.keys()]) if body else ""
                if any(k in lowered for k in ["deprecated", "experimental", "beta", "warning"]):
                    scan_evidence = f"Method: {method}\nPath: {test_path}\nResponse contained deprecated/experimental indicators"
                    sr = ScanResult(
                        9,
                        OWASP_FLAGS.IIM.value,
                        endpoint,
                        risk_level,
                        5,
                        "Deprecated/experimental endpoint accessible in production.",
                        "Remove experimental endpoints from production or restrict access.",
                        scan_evidence,
                        "Experimental/deprecated endpoint exposed",
                        {"response_keys": list(body.keys())}
                    )
                    results.append(sr)

                # 3) Exposed secrets / plaintext passwords or auth bypass flags
                # scan top-level and one-level-deep keys/values
                found_secrets = []
                def _scan_obj(obj):
                    if not isinstance(obj, dict):
                        return
                    for k, v in obj.items():
                        kl = k.lower()
                        if any(sf in kl for sf in sensitive_field_indicators):
                            found_secrets.append(k)
                        # values that look like secrets
                        if isinstance(v, str) and any(ind in v.lower() for ind in sensitive_field_indicators):
                            if k not in found_secrets:
                                found_secrets.append(k)

                _scan_obj(body)
                for v in body.values() if isinstance(body, dict) else []:
                    if isinstance(v, dict):
                        _scan_obj(v)

                if found_secrets:
                    scan_evidence = f"Method: {method}\nPath: {test_path}\nExposed fields: {found_secrets}"
                    sr = ScanResult(
                        9,
                        OWASP_FLAGS.IIM.value,
                        endpoint,
                        risk_level,
                        6,
                        "Endpoint exposes sensitive inventory or legacy test data (secrets/passwords).",
                        "Remove secrets and deprecated test data from production endpoints; enforce inventory hygiene.",
                        scan_evidence,
                        "Exposed secrets / legacy data",
                        {"exposed_fields": found_secrets}
                    )
                    results.append(sr)

            # 4) If response is a list, check first few items for password/secret fields
            if isinstance(body, list) and len(body) > 0:
                sample = body[:5]
                found = []
                for item in sample:
                    if isinstance(item, dict):
                        for k in item.keys():
                            if any(sf in k.lower() for sf in sensitive_field_indicators):
                                if k not in found:
                                    found.append(k)
                        for v in item.values():
                            if isinstance(v, str) and any(ind in v.lower() for ind in sensitive_field_indicators):
                                # include a synthetic key to indicate value leak
                                if "value_leak" not in found:
                                    found.append("value_leak")
                if found:
                    scan_evidence = f"Method: {method}\nPath: {test_path}\nList items exposed fields: {found}"
                    sr = ScanResult(
                        9,
                        OWASP_FLAGS.IIM.value,
                        endpoint,
                        risk_level,
                        6,
                        "Endpoint returns legacy inventory or test data containing secrets.",
                        "Remove legacy endpoints and scrub sensitive test data from responses.",
                        scan_evidence,
                        "List response contains secrets/legacy data",
                        {"sample_exposed": found}
                    )
                    results.append(sr)

        except Exception:
            # keep scanning other endpoints even if analysis of one fails
            pass

    return results


# --- New, discovery-focused test for Zombie APIs ---
def test_for_zombie_apis(api_client, endpoints, risk_level):
    """
    Searches for older, deprecated, or undocumented API versions by fuzzing path prefixes.
    """
    results = []
    base_url = api_client.get_url()
    http_interface = HTTPInterface(base_url)
    http_interface.add_header(api_client.get_auth_header())

    VERSION_PREFIXES = ['/v1', '/v2', '/v0', '/v1.1', '/beta', '/test', '/dev']
    
    # Use a set to avoid testing the same fuzzed path multiple times
    tested_paths = set()

    print("[*] Starting Zombie API discovery test...")
    for endpoint in endpoints:
        original_path = endpoint.path
        
        # Regex to find existing version prefixes like /v1, /v1.1, etc.
        version_match = re.search(r'(/(v[0-9.]+))', original_path)
        
        fuzz_paths = set()

        if version_match:
            # Path already has a version, e.g., /api/v2/users
            # Try replacing it with other versions
            existing_prefix = version_match.group(1)
            base_path = original_path.replace(existing_prefix, '')
            for prefix in VERSION_PREFIXES:
                if prefix != existing_prefix:
                    fuzz_paths.add(f"{prefix}{base_path}")
        else:
            # Path has no version, e.g., /api/users
            # Try prepending version prefixes
            for prefix in VERSION_PREFIXES:
                fuzz_paths.add(f"{prefix}{original_path}")

        for test_path in fuzz_paths:
            if test_path in tested_paths:
                continue
            tested_paths.add(test_path)
            
            # Use OPTIONS as a lightweight way to check for endpoint existence
            response = http_interface.send_custom("OPTIONS", test_path)
            
            # Any response other than 404 indicates the endpoint exists
            if response.status_code != 404:
                scan_evidence = (
                    f"Original documented path: {original_path}\n"
                    f"Fuzzed path: OPTIONS {test_path}\n"
                    f"Result: Received status code {response.status_code}, indicating the undocumented endpoint exists."
                )
                sr = ScanResult(
                    owasp_category=OWASP_FLAGS.IIM.value,
                    vulnerability_name="Zombie or Shadow API Detected",
                    endpoint=endpoint, # Report against the original endpoint for context
                    severity=risk_level,
                    description=f"An undocumented or deprecated API version was discovered at '{test_path}'. These 'zombie' endpoints are often unpatched and lack modern security controls.",
                    recommendation="Maintain a complete and accurate inventory of all deployed API versions. Decommission and block access to any versions that are no longer supported.",
                    evidence=scan_evidence,
                    test_name="API Version Fuzzing"
                )
                results.append(sr)
                print(f"[!!!] VULNERABILITY FOUND: Zombie/Shadow API at {test_path} (original: {original_path})")
                
    return results