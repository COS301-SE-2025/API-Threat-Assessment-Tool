# core/vulnerability_tests/SEC_MISC.py

from core.scan_result import ScanResult
from core.http_interface import HTTPInterface
from core.owasp_flags import OWASP_FLAGS
import re

def test_misconfig(api_client, endpoints, risk_level):
    results = []
    # Test security misconfiguration
    for endpoint in endpoints:
        if OWASP_FLAGS.SEC_MISC not in endpoint.get_flags():
            continue
        # Check for security headers
        http_interface = HTTPInterface(api_client.get_url())
        response = http_interface.send_custom(endpoint.method, endpoint.path)
        if "Content-Security-Policy" not in response.headers:
            scan_evidence = f"Method: {endpoint.method}\nPath: {endpoint.path}\nHeader: Content-Security-Policy not found"
            sr = ScanResult(
                8,
                OWASP_FLAGS.SEC_MISC.value,
                endpoint,
                risk_level,
                6,
                "Security misconfiguration: Content-Security-Policy header not found",
                "Implement Content-Security-Policy header",
                scan_evidence,
                "Security misconfiguration",
                {}
            )
            results.append(sr)
    return results


# --- New, more comprehensive misconfiguration tests ---

def test_security_headers_and_cors(api_client, endpoints, risk_level):
    """Checks for a baseline of secure headers and for permissive CORS policies."""
    results = []
    
    # Define a policy for recommended security headers
    SECURE_HEADERS_POLICY = {
        "Strict-Transport-Security": {"required": True},
        "X-Content-Type-Options": {"required": True, "expected_value": "nosniff"},
        "X-Frame-Options": {"required": True, "expected_value": ["DENY", "SAMEORIGIN"]},
    }

    # We only need to check one endpoint, as headers are often set globally
    if not endpoints:
        return results
    endpoint_to_test = endpoints[0]
    
    print(f"[*] Starting Security Header and CORS check on {endpoint_to_test.method} {endpoint_to_test.path}...")
    http_interface = HTTPInterface(api_client.get_url())
    response = http_interface.send_custom(endpoint_to_test.method, endpoint_to_test.path)
    headers = response.headers

    # Check for missing or insecure headers
    for header, policy in SECURE_HEADERS_POLICY.items():
        if policy["required"] and header not in headers:
            sr = ScanResult(
                owasp_category=OWASP_FLAGS.SEC_MISC.value, vulnerability_name=f"Missing Security Header: {header}",
                endpoint=endpoint_to_test, severity="Low",
                description=f"The HTTP '{header}' security header is not present in the API response. This header provides an important layer of defense for web clients.",
                recommendation=f"Ensure the '{header}' header is present in all API responses.",
                evidence=f"The '{header}' header was missing from the response.", test_name="Secure Header Check"
            )
            results.append(sr)
            print(f"[!!!] VULNERABILITY FOUND: Missing '{header}' header.")
    
    # Check for permissive CORS
    if headers.get("Access-Control-Allow-Origin") == "*":
        sr = ScanResult(
            owasp_category=OWASP_FLAGS.SEC_MISC.value, vulnerability_name="Permissive CORS Policy",
            endpoint=endpoint_to_test, severity="Medium",
            description="The API is configured with an overly permissive CORS policy (Access-Control-Allow-Origin: *), allowing any malicious website to make requests to it from a victim's browser.",
            recommendation="Restrict the Access-Control-Allow-Origin header to only the specific domains that need to access the API.",
            evidence="The 'Access-Control-Allow-Origin' header was set to '*'.", test_name="Permissive CORS Check"
        )
        results.append(sr)
        print("[!!!] VULNERABILITY FOUND: Permissive CORS policy (allow all).")

    return results


def test_verbose_error_messages(api_client, endpoints, risk_level):
    """Intentionally triggers errors to check for information leakage."""
    results = []
    
    VERBOSE_ERROR_PATTERNS = [
        re.compile(r"exception in thread", re.IGNORECASE),
        re.compile(r"stack trace", re.IGNORECASE),
        re.compile(r"traceback \(most recent call last\)", re.IGNORECASE),
        re.compile(r"sql syntax.*?error", re.IGNORECASE),
        re.compile(r"ORA-[0-9]{5}", re.IGNORECASE), # Oracle DB errors
        re.compile(r"Microsoft OLE DB Provider for SQL Server", re.IGNORECASE),
        re.compile(r"/var/www/html", re.IGNORECASE), # Common web root
        re.compile(r"c:\\inetpub\\wwwroot", re.IGNORECASE),
    ]

    if not endpoints:
        return results
    endpoint_to_test = endpoints[0]

    print(f"[*] Starting Verbose Error Message check on {endpoint_to_test.method} {endpoint_to_test.path}...")
    http_interface = HTTPInterface(api_client.get_url())
    http_interface.add_header(api_client.get_auth_header())

    # Send a malformed request likely to cause a 500 error
    malformed_path = f"{endpoint_to_test.path}?scanner_test_param='invalid_sql"
    response = http_interface.send_custom(endpoint_to_test.method, malformed_path)

    if 400 <= response.status_code < 600:
        for pattern in VERBOSE_ERROR_PATTERNS:
            if pattern.search(response.text):
                scan_evidence = (
                    f"Sent a malformed request to: {malformed_path}\n"
                    f"Server responded with status {response.status_code}.\n"
                    f"The response body contained sensitive information matching the pattern: '{pattern.pattern}'"
                )
                sr = ScanResult(
                    owasp_category=OWASP_FLAGS.SEC_MISC.value, vulnerability_name="Verbose Error Message",
                    endpoint=endpoint_to_test, severity="Low",
                    description="Error responses contain sensitive information like stack traces, database errors, or internal file paths. This information can help an attacker map the backend technology and plan targeted attacks.",
                    recommendation="Configure the server to return generic, non-detailed error messages. Log detailed errors on the server-side for debugging.",
                    evidence=scan_evidence, test_name="Information Leakage in Errors"
                )
                results.append(sr)
                print(f"[!!!] VULNERABILITY FOUND: Verbose error message detected.")
                break # Report once per endpoint
    
    return results

def test_security_misconfigurations(api_client, endpoints, risk_level):
    """Orchestrator for all new security misconfiguration tests."""
    all_results = []
    all_results.extend(test_security_headers_and_cors(api_client, endpoints, risk_level))
    all_results.extend(test_verbose_error_messages(api_client, endpoints, risk_level))
    return all_results