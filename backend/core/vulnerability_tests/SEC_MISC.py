# core/vulnerability_tests/SEC_MISC.py

from core.scan_result import ScanResult
from core.http_interface import HTTPInterface
from core.owasp_flags import OWASP_FLAGS
import re

def test_misconfig(api_client, endpoints, risk_level):
    results = []
    for endpoint in endpoints:
        if OWASP_FLAGS.SEC_MISC not in endpoint.get_flags() or OWASP_FLAGS.SKIP in endpoint.get_flags():
            continue
            
        http_interface = HTTPInterface(api_client.get_url())
        response = http_interface.send_custom(endpoint.method, endpoint.path)
        if "Content-Security-Policy" not in response.headers:
            scan_evidence = f"Method: {endpoint.method}\nPath: {endpoint.path}\nHeader: Content-Security-Policy not found"
            sr = ScanResult(
                owasp_category=OWASP_FLAGS.SEC_MISC.value,
                vulnerability_name="8. Missing Content-Security-Policy Header",
                endpoint=endpoint,
                severity=risk_level,
                description="Security misconfiguration: Content-Security-Policy header not found. This header helps prevent Cross-Site Scripting (XSS) and other code injection attacks.",
                recommendation="Implement a robust Content-Security-Policy (CSP) header to control which resources the user agent is allowed to load.",
                evidence=scan_evidence,
                test_name="Missing CSP Header"
            )
            results.append(sr)
    return results

def find_first_valid_endpoint(endpoints):
    """Helper to find the first endpoint that is not skipped."""
    for ep in endpoints:
        if OWASP_FLAGS.SKIP not in ep.get_flags():
            return ep
    return None

def test_security_headers_and_cors(api_client, endpoints, risk_level):
    """Checks for a baseline of secure headers and for permissive CORS policies."""
    results = []
    
    SECURE_HEADERS_POLICY = {
        "Strict-Transport-Security": {"required": True},
        "X-Content-Type-Options": {"required": True, "expected_value": "nosniff"},
        "X-Frame-Options": {"required": True, "expected_value": ["DENY", "SAMEORIGIN"]},
    }

    endpoint_to_test = find_first_valid_endpoint(endpoints)
    if not endpoint_to_test:
        return results
    
    print(f"[*] Starting Security Header and CORS check on {endpoint_to_test.method} {endpoint_to_test.path}...")
    http_interface = HTTPInterface(api_client.get_url())
    response = http_interface.send_custom(endpoint_to_test.method, endpoint_to_test.path)
    headers = response.headers

    for header, policy in SECURE_HEADERS_POLICY.items():
        if policy["required"] and header not in headers:
            sr = ScanResult(
                owasp_category=OWASP_FLAGS.SEC_MISC.value, vulnerability_name=f"8. Missing Security Header: {header}",
                endpoint=endpoint_to_test, severity="Low",
                description=f"The HTTP '{header}' security header is not present in the API response. This header provides an important layer of defense for web clients.",
                recommendation=f"Ensure the '{header}' header is present in all API responses.",
                evidence=f"The '{header}' header was missing from the response.", test_name="Secure Header Check"
            )
            results.append(sr)
            print(f"[!!!] VULNERABILITY FOUND: Missing '{header}' header.")
    
    if headers.get("Access-Control-Allow-Origin") == "*":
        sr = ScanResult(
            owasp_category=OWASP_FLAGS.SEC_MISC.value, vulnerability_name="8. Permissive CORS Policy",
            endpoint=endpoint_to_test, severity="Medium",
            description="The API is configured with an overly permissive CORS policy (Access-Control-Allow-Origin: *), allowing any malicious website to make requests to it from a victim's browser.",
            recommendation="Restrict the Access-Control-Allow-Origin header to only the specific domains that need to access the API.",
            evidence="The 'Access-Control-Allow-Origin' header was set to '*'.", test_name="Permissive CORS Check"
        )
        results.append(sr)
        print("[!!!] VULNERABILITY FOUND: Permissive CORS policy (allow all).")

    return results

def test_verbose_error_messages(api_client, endpoints, risk_level):
    """Intentionally triggers errors to check for information leakage."""
    results = []
    
    VERBOSE_ERROR_PATTERNS = [
        re.compile(r"exception in thread", re.IGNORECASE),
        re.compile(r"stack trace", re.IGNORECASE),
        re.compile(r"traceback \(most recent call last\)", re.IGNORECASE),
        re.compile(r"sql syntax.*?error", re.IGNORECASE),
        re.compile(r"ORA-[0-9]{5}", re.IGNORECASE),
        re.compile(r"Microsoft OLE DB Provider for SQL Server", re.IGNORECASE),
        re.compile(r"/var/www/html", re.IGNORECASE),
        re.compile(r"c:\\inetpub\\wwwroot", re.IGNORECASE),
    ]

    endpoint_to_test = find_first_valid_endpoint(endpoints)
    if not endpoint_to_test:
        return results

    print(f"[*] Starting Verbose Error Message check on {endpoint_to_test.method} {endpoint_to_test.path}...")
    http_interface = HTTPInterface(api_client.get_url())
    http_interface.add_header(api_client.get_auth_header())

    malformed_path = f"{endpoint_to_test.path}?scanner_test_param='invalid_sql"
    response = http_interface.send_custom(endpoint_to_test.method, malformed_path)

    if 400 <= response.status_code < 600:
        for pattern in VERBOSE_ERROR_PATTERNS:
            if pattern.search(response.text):
                scan_evidence = (
                    f"Sent a malformed request to: {malformed_path}\n"
                    f"Server responded with status {response.status_code}.\n"
                    f"The response body contained sensitive information matching the pattern: '{pattern.pattern}'"
                )
                sr = ScanResult(
                    owasp_category=OWASP_FLAGS.SEC_MISC.value, vulnerability_name="8. Verbose Error Message",
                    endpoint=endpoint_to_test, severity="Low",
                    description="Error responses contain sensitive information like stack traces, database errors, or internal file paths. This information can help an attacker map the backend technology and plan targeted attacks.",
                    recommendation="Configure the server to return generic, non-detailed error messages. Log detailed errors on the server-side for debugging.",
                    evidence=scan_evidence, test_name="Information Leakage in Errors"
                )
                results.append(sr)
                print(f"[!!!] VULNERABILITY FOUND: Verbose error message detected.")
                break
    
    return results

def test_security_misconfigurations(api_client, endpoints, risk_level):
    """Orchestrator for all new security misconfiguration tests."""
    all_results = []
    all_results.extend(test_security_headers_and_cors(api_client, endpoints, risk_level))
    all_results.extend(test_verbose_error_messages(api_client, endpoints, risk_level))
    return all_results