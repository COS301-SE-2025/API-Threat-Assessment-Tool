# core/vulnerability_tests/SSRF.py

from core.scan_result import ScanResult
from core.http_interface import HTTPInterface
from core.owasp_flags import OWASP_FLAGS
import requests
import uuid
import time

# --- Original function, preserved for unit tests ---
def test_ssrf(api_client, endpoints, risk_level):
    base_url = api_client.get_url()
    http_interface = HTTPInterface(base_url)

    try:
        auth_hdr = api_client.get_auth_header()
        http_interface.add_header(auth_hdr)
    except Exception:
        pass

    results = []

    # payloads targeting internal services / metadata APIs
    ssrf_payloads = [
        "http://127.0.0.1",
        "http://localhost",
        "https://www.google.com",
    ]

    for endpoint in endpoints:
        if OWASP_FLAGS.SSRF not in endpoint.get_flags():
            continue

        if OWASP_FLAGS.SKIP in endpoint.get_flags():
            continue

        method = (endpoint.method or "").upper()
        path = endpoint.path or ""

        # Detect query param style SSRF
        if method == "GET":
            for payload in ssrf_payloads:
                if "{path}" in path:
                    test_path = path.replace("{path}", payload)
                else:
                    # append ?url= or ?callback_url= depending on param
                    if "{" not in path:
                        sep = "&" if "?" in path else "?"
                        test_path = f"{path}{sep}url={payload}"
                    else:
                        continue

                resp = http_interface.send_custom("GET", test_path)
                if resp and resp.status_code < 500 and payload in resp.text:
                    sr = ScanResult(
                        7,
                        OWASP_FLAGS.SSRF.value,
                        endpoint,
                        risk_level,
                        9,
                        "Endpoint appears vulnerable to SSRF.",
                        "Validate and restrict outgoing requests to allowed hosts.",
                        f"Sent {payload}, received status {resp.status_code}",
                        "SSRF confirmed",
                        {"payload": payload, "status": resp.status_code}
                    )
                    results.append(sr)

        elif method == "POST":
            for payload in ssrf_payloads:
                body = {}
                if "webhook" in path.lower():
                    body = {"callback_url": payload, "data": {"test": "123"}}
                else:
                    body = {"url": payload}

                resp = http_interface.send_custom("POST", path, json=body)
                if resp and resp.status_code < 500 and payload in resp.text:
                    sr = ScanResult(
                        7,
                        OWASP_FLAGS.SSRF.value,
                        endpoint,
                        risk_level,
                        9,
                        "Endpoint appears vulnerable to SSRF.",
                        "Validate and restrict outgoing requests to allowed hosts.",
                        f"Sent {payload}, received status {resp.status_code}",
                        "SSRF confirmed",
                        {"payload": payload, "status": resp.status_code}
                    )
                    results.append(sr)

    return results


# --- New, advanced OAST-based test for Blind SSRF ---
def test_ssrf_oast(api_client, endpoints, risk_level):
    results = []
    # IMPORTANT: Replace this with the public URL of your OAST server (e.g., from ngrok)
    OAST_BASE_URL = "http://localhost:8001" 
    
    url_param_keywords = ['url', 'uri', 'link', 'fetch', 'webhook', 'image', 'feed', 'import', 'redirect']

    for endpoint in endpoints:
        print(f"[*] Starting OAST SSRF test on {endpoint.method} {endpoint.path}...")
        
        # Find all parameters that might accept a URL
        candidate_params = []
        for param in endpoint.parameters:
            if any(keyword in param.get("name", "").lower() for keyword in url_param_keywords):
                candidate_params.append(param)
        
        if not candidate_params:
            continue

        http_interface = HTTPInterface(api_client.get_url())
        http_interface.add_header(api_client.get_auth_header())

        for param in candidate_params:
            test_id = str(uuid.uuid4())
            oast_payload_url = f"{OAST_BASE_URL}/log/{test_id}"
            
            # Inject payload based on parameter location
            if param.get('in') == 'query':
                http_interface.send_custom(endpoint.method, endpoint.path, params={param['name']: oast_payload_url})
            elif endpoint.method.upper() in ['POST', 'PUT', 'PATCH']:
                http_interface.send_custom(endpoint.method, endpoint.path, json={param['name']: oast_payload_url})
            else:
                continue

            # Wait for the out-of-band request to happen
            print(f"  [+] Injected OAST payload in param '{param['name']}'. Waiting for interaction...")
            time.sleep(5)

            # Poll the OAST server to check for interactions
            try:
                poll_url = f"{OAST_BASE_URL}/poll/{test_id}"
                response = requests.get(poll_url, timeout=5)
                interactions = response.json()
                
                if interactions:
                    interaction_details = interactions[0] # Log the first interaction
                    scan_evidence = (
                        f"Injected an OAST payload into the '{param['name']}' parameter: {oast_payload_url}\n"
                        f"The collaborator server received a request from IP: {interaction_details.get('remote_ip')}\n"
                        f"This confirms the server is making outbound requests based on user input, proving SSRF."
                    )
                    sr = ScanResult(
                        owasp_category=OWASP_FLAGS.SSRF.value,
                        vulnerability_name="Server-Side Request Forgery (Blind)",
                        endpoint=endpoint, severity="High",
                        description="The application fetches a remote resource using a user-supplied URL without proper validation. This allows an attacker to coerce the server into sending crafted requests to unintended locations, including internal services.",
                        recommendation="Do not trust user-supplied URLs. Use a strict allow-list to validate that the URL points to a permitted destination and protocol before making any requests.",
                        evidence=scan_evidence, test_name="OAST Blind SSRF",
                        affected_params={param['name']: oast_payload_url}
                    )
                    results.append(sr)
                    print(f"[!!!] VULNERABILITY FOUND: Blind SSRF confirmed via OAST for param '{param['name']}'")
            except requests.RequestException as e:
                print(f"[WARN] Could not connect to OAST server at {OAST_BASE_URL}. Is it running? Error: {e}")
                return results # Abort OAST tests if server is down

    return results