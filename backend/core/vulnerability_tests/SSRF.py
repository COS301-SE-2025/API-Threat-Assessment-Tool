# core/vulnerability_tests/SSRF.py

from core.scan_result import ScanResult
from core.http_interface import HTTPInterface
from core.owasp_flags import OWASP_FLAGS
import requests
import uuid
import time

# --- Original function, preserved for unit tests ---
def test_ssrf(api_client, endpoints, risk_level):
    base_url = api_client.get_url()
    http_interface = HTTPInterface(base_url)
    try:
        http_interface.add_header(api_client.get_auth_header())
    except Exception:
        pass
    results = []
    ssrf_payloads = ["http://127.0.0.1", "http://localhost", "https://www.google.com"]

    for endpoint in endpoints:
        if OWASP_FLAGS.SSRF not in endpoint.get_flags() or OWASP_FLAGS.SKIP in endpoint.get_flags():
            continue
        method = (endpoint.method or "").upper()
        path = endpoint.path or ""

        if method == "GET":
            for payload in ssrf_payloads:
                sep = "&" if "?" in path else "?"
                test_path = f"{path}{sep}url={payload}"
                resp = http_interface.send_custom("GET", test_path)
                if resp and resp.status_code < 500 and payload in resp.text:
                    sr = ScanResult(
                        owasp_category=OWASP_FLAGS.SSRF.value, vulnerability_name="Potential SSRF (In-band)",
                        endpoint=endpoint, severity=risk_level,
                        description="Endpoint appears vulnerable to SSRF. The server response included content from the requested URL.",
                        recommendation="Validate and sanitize all user-supplied input that is used in outbound requests. Use a strict allow-list of permitted domains.",
                        evidence=f"Sent {payload}, received status {resp.status_code}",
                        test_name="In-band SSRF Check",
                        affected_params={"url": payload, "status": resp.status_code}
                    )
                    results.append(sr)
        elif method == "POST":
            for payload in ssrf_payloads:
                body = {"url": payload}
                resp = http_interface.send_custom("POST", path, json=body)
                if resp and resp.status_code < 500 and payload in resp.text:
                    sr = ScanResult(
                        owasp_category=OWASP_FLAGS.SSRF.value, vulnerability_name="Potential SSRF (In-band)",
                        endpoint=endpoint, severity=risk_level,
                        description="Endpoint appears vulnerable to SSRF. The server response included content from the requested URL.",
                        recommendation="Validate and sanitize all user-supplied input that is used in outbound requests. Use a strict allow-list of permitted domains.",
                        evidence=f"Sent {payload}, received status {resp.status_code}",
                        test_name="In-band SSRF Check",
                        affected_params={"url": payload, "status": resp.status_code}
                    )
                    results.append(sr)
    return results


# --- New, advanced OAST-based test for Blind SSRF ---
def test_ssrf_oast(api_client, endpoints, risk_level):
    results = []
    # IMPORTANT: Replace this with the public URL of your OAST server (e.g., from ngrok)
    OAST_BASE_URL = "http://localhost:8001" 
    
    url_param_keywords = ['url', 'uri', 'link', 'fetch', 'webhook', 'image', 'feed', 'import', 'redirect']

    for endpoint in endpoints:
        print(f"[*] Starting OAST SSRF test on {endpoint.method} {endpoint.path}...")
        
        # Find all parameters that might accept a URL
        candidate_params = []
        for param in endpoint.parameters:
            if any(keyword in param.get("name", "").lower() for keyword in url_param_keywords):
                candidate_params.append(param)
        
        if not candidate_params:
            continue

        http_interface = HTTPInterface(api_client.get_url())
        http_interface.add_header(api_client.get_auth_header())

        for param in candidate_params:
            test_id = str(uuid.uuid4())
            oast_payload_url = f"{OAST_BASE_URL}/log/{test_id}"
            
            # Inject payload based on parameter location
            if param.get('in') == 'query':
                http_interface.send_custom(endpoint.method, endpoint.path, params={param['name']: oast_payload_url})
            elif endpoint.method.upper() in ['POST', 'PUT', 'PATCH']:
                http_interface.send_custom(endpoint.method, endpoint.path, json={param['name']: oast_payload_url})
            else:
                continue

            # Wait for the out-of-band request to happen
            print(f"  [+] Injected OAST payload in param '{param['name']}'. Waiting for interaction...")
            time.sleep(5)

            # Poll the OAST server to check for interactions
            try:
                poll_url = f"{OAST_BASE_URL}/poll/{test_id}"
                response = requests.get(poll_url, timeout=5)
                interactions = response.json()
                
                if interactions:
                    interaction_details = interactions[0] # Log the first interaction
                    scan_evidence = (
                        f"Injected an OAST payload into the '{param['name']}' parameter: {oast_payload_url}\n"
                        f"The collaborator server received a request from IP: {interaction_details.get('remote_ip')}\n"
                        f"This confirms the server is making outbound requests based on user input, proving SSRF."
                    )
                    sr = ScanResult(
                        owasp_category=OWASP_FLAGS.SSRF.value,
                        vulnerability_name="Server-Side Request Forgery (Blind)",
                        endpoint=endpoint, severity="High",
                        description="The application fetches a remote resource using a user-supplied URL without proper validation. This allows an attacker to coerce the server into sending crafted requests to unintended locations, including internal services.",
                        recommendation="Do not trust user-supplied URLs. Use a strict allow-list to validate that the URL points to a permitted destination and protocol before making any requests.",
                        evidence=scan_evidence, test_name="OAST Blind SSRF",
                        affected_params={param['name']: oast_payload_url}
                    )
                    results.append(sr)
                    print(f"[!!!] VULNERABILITY FOUND: Blind SSRF confirmed via OAST for param '{param['name']}'")
            except requests.RequestException as e:
                print(f"[WARN] Could not connect to OAST server at {OAST_BASE_URL}. Is it running? Error: {e}")
                return results # Abort OAST tests if server is down

    return results