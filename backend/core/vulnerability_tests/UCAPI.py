# core/vulnerability_tests/UCAPI.py

from core.scan_result import ScanResult
from core.http_interface import HTTPInterface
from core.owasp_flags import OWASP_FLAGS

# --- Original function, preserved for unit tests ---
def test_unsafe_consumption(api_client, endpoints, risk_level):
    results = []
    # Test API consumption
    for endpoint in endpoints:
        if OWASP_FLAGS.UCAPI not in endpoint.get_flags():
            continue
        # Send request with malicious API call
        http_interface = HTTPInterface(api_client.get_url())
        response = http_interface.send_custom(endpoint.method, endpoint.path)
        if response.status_code == 200:
            scan_evidence = f"Method: {endpoint.method}\nPath: {endpoint.path}\nStatus: {response.status_code}"
            sr = ScanResult(
                10,
                OWASP_FLAGS.UCAPI.value,
                endpoint,
                risk_level,
                8,
                "Unsafe consumption of APIs: endpoint consumes malicious API",
                "Validate and restrict API calls",
                scan_evidence,
                "API consumption vulnerability",
                {}
            )
            results.append(sr)
    return results


# --- New, advanced test using API mocking ---
def test_unsafe_consumption_with_mocking(api_client, endpoints, risk_level):
    """
    Tests if the application safely handles malicious data from a (mocked) third-party API.
    """
    results = []
    XSS_PAYLOAD = "<script>alert('XSS_from_third_party')</script>"

    print("[*] Starting Unsafe Consumption test with API mocking...")
    for endpoint in endpoints:
        print(f"  [*] Testing endpoint {endpoint.method} {endpoint.path}, assuming it consumes a mocked API.")
        
        http_interface = HTTPInterface(api_client.get_url())
        http_interface.add_header(api_client.get_auth_header())

        # Step 1: Trigger the endpoint in our application that calls the external API.
        response = http_interface.send_custom(endpoint.method, endpoint.path)

        if response.status_code != 200:
            print(f"  [INFO] Endpoint returned non-200 status: {response.status_code}. Skipping XSS check.")
            continue

        # Step 2: Analyze the application's response to see if the malicious payload is reflected without sanitization.
        if XSS_PAYLOAD in response.text:
            scan_evidence = (
                f"1. A mock third-party API was configured to return a response containing an XSS payload: '{XSS_PAYLOAD}'.\n"
                f"2. The scanner called your application's endpoint: {endpoint.method} {endpoint.path}.\n"
                f"3. Your application's final response included the raw, unsanitized XSS payload, indicating it blindly trusted the data from the third-party API."
            )
            sr = ScanResult(
                owasp_category=OWASP_FLAGS.UCAPI.value,
                vulnerability_name="Reflected XSS from Third-Party API",
                endpoint=endpoint,
                severity="High",
                description="The application did not properly sanitize or validate data received from an external API, leading to a Cross-Site Scripting (XSS) vulnerability. An attacker who compromises the third-party service could inject malicious scripts into your application.",
                recommendation="Treat data from all external APIs with the same scrutiny as user-generated input. Always validate, sanitize, and properly encode data from third-party services before processing or displaying it.",
                evidence=scan_evidence,
                test_name="API Mocking for XSS"
            )
            results.append(sr)
            print(f"[!!!] VULNERABILITY FOUND: Reflected XSS from third-party API via {endpoint.path}")
        else:
            print(f"  [OK] XSS payload was not found in the response for {endpoint.path}.")
            
    return results