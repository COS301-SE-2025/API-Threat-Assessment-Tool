# core/vulnerability_tests/URC.py

from core.scan_result import ScanResult
from core.http_interface import HTTPInterface
from core.owasp_flags import OWASP_FLAGS, ENDPOINT_FLAGS
import threading
import requests

def test_resource_consumption(api_client, endpoints, risk_level):
    results = []
    for endpoint in endpoints:
        if OWASP_FLAGS.URC not in endpoint.get_flags() or OWASP_FLAGS.SKIP in endpoint.get_flags():
            continue

        http_interface = HTTPInterface(api_client.get_url())
        for i in range(10): # Reduced from 200 for faster testing
            response = http_interface.send_custom(endpoint.method, endpoint.path)
            if response.status_code != 200:
                break
        if response.status_code != 429:
            scan_evidence = f"Method: {endpoint.method}\nPath: {endpoint.path}\nStatus: {response.status_code}"
            sr = ScanResult(
                owasp_category=OWASP_FLAGS.URC.value,
                vulnerability_name="4. Missing Rate Limiting (Sequential Test)",
                endpoint=endpoint,
                severity=risk_level,
                description="Unrestricted resource consumption vulnerability: endpoint did not return 429 after 10 sequential requests.",
                recommendation="Implement rate limiting on all endpoints to prevent denial-of-service attacks.",
                evidence=scan_evidence,
                test_name="Sequential Rate Limit Check"
            )
            results.append(sr)
    return results

def test_rate_limiting_concurrent(api_client, endpoints, risk_level):
    """Sends a concurrent burst of requests to check for rate limiting."""
    results = []
    num_requests = 100 # Number of concurrent requests to send in a burst

    for endpoint in endpoints:
        if OWASP_FLAGS.SKIP in endpoint.get_flags():
            continue

        print(f"[*] Starting concurrent rate limit test on {endpoint.method} {endpoint.path}...")
        responses = []
        
        def send_request():
            # Each thread gets its own HTTPInterface to avoid state conflicts
            http_interface = HTTPInterface(api_client.get_url())
            http_interface.add_header(api_client.get_auth_header())
            response = http_interface.send_custom(endpoint.method, endpoint.path)
            responses.append(response)

        threads = [threading.Thread(target=send_request) for _ in range(num_requests)]
        for t in threads: t.start()
        for t in threads: t.join()

        status_codes = [r.status_code for r in responses if r is not None]
        if not status_codes: continue

        if 429 not in status_codes:
            scan_evidence = f"Sent {num_requests} concurrent requests to {endpoint.method} {endpoint.path}.\nReceived status codes: {dict((i, status_codes.count(i)) for i in set(status_codes))}.\nNo 429 'Too Many Requests' response was observed."
            sr = ScanResult(
                owasp_category=OWASP_FLAGS.URC.value,
                vulnerability_name="4. Missing Rate Limiting (Concurrent Test)",
                endpoint=endpoint,
                severity=risk_level,
                description="The API does not effectively limit the rate of incoming requests, making it vulnerable to Denial of Service (DoS) attacks.",
                recommendation="Implement and enforce rate limiting based on factors like IP address, API key, or user ID.",
                evidence=scan_evidence,
                test_name="Concurrent Rate Limit Burst"
            )
            results.append(sr)
            print(f"[!!!] VULNERABILITY FOUND: Missing rate limiting on {endpoint.path}")
        else:
            print(f"[OK] Rate limiting appears to be in place for {endpoint.path}")
            
    return results

def test_large_payload(api_client, endpoints, risk_level):
    """Sends an oversized payload to endpoints that accept request bodies."""
    results = []
    # Create a ~10MB JSON payload
    large_payload = {"data": "A" * (10 * 1024 * 1024)} 
    
    for endpoint in endpoints:
        if OWASP_FLAGS.SKIP in endpoint.get_flags():
            continue
            
        print(f"[*] Starting large payload test on {endpoint.method} {endpoint.path}...")
        http_interface = HTTPInterface(api_client.get_url())
        http_interface.add_header(api_client.get_auth_header())
        
        try:
            # Set a timeout to detect performance degradation / DoS
            response = http_interface.send_custom(endpoint.method, endpoint.path, json=large_payload, timeout=15)
            
            if response.status_code >= 500:
                subtype = "4. Server Error on Large Payload"
                desc = "The server returned an internal error when processing an oversized payload, which could lead to a denial-of-service condition."
            elif response.status_code not in [400, 413]: # 413 is "Payload Too Large"
                subtype = "4. Large Payload Accepted"
                desc = "The server accepted an unusually large payload without complaint, suggesting a lack of input size validation which can lead to resource exhaustion."
            else:
                print(f"[OK] Server correctly rejected large payload on {endpoint.path} with status {response.status_code}")
                continue
            
            scan_evidence = f"Sent a ~10MB JSON payload to {endpoint.method} {endpoint.path}.\nServer responded with status code: {response.status_code}."
            sr = ScanResult(
                owasp_category=OWASP_FLAGS.URC.value, vulnerability_name=subtype,
                endpoint=endpoint, severity=risk_level, description=desc,
                recommendation="Enforce strict limits on the size of request bodies and files. Reject any request exceeding the limit with a 413 status code.",
                evidence=scan_evidence, test_name="Large Payload Submission"
            )
            results.append(sr)
            print(f"[!!!] VULNERABILITY FOUND: {subtype} on {endpoint.path}")

        except requests.exceptions.Timeout:
            scan_evidence = f"Sent a ~10MB JSON payload to {endpoint.method} {endpoint.path}.\nThe request timed out after 15 seconds."
            sr = ScanResult(
                owasp_category=OWASP_FLAGS.URC.value, vulnerability_name="4. Request Timeout on Large Payload",
                endpoint=endpoint, severity="High", description="The server timed out while processing an oversized payload, indicating a high risk of denial-of-service.",
                recommendation="Ensure the server can handle large requests gracefully without timing out, or enforce strict size limits.",
                evidence=scan_evidence, test_name="Large Payload Submission (Timeout)"
            )
            results.append(sr)
            print(f"[!!!] VULNERABILITY FOUND: Request Timeout on {endpoint.path}")
        except Exception as e:
            print(f"[WARN] Error during large payload test for {endpoint.path}: {e}")

    return results

def test_pagination_abuse(api_client, endpoints, risk_level):
    """Fuzzes pagination parameters with large values."""
    results = []
    
    for endpoint, param_name in endpoints:
        if OWASP_FLAGS.SKIP in endpoint.get_flags():
            continue

        print(f"[*] Starting pagination abuse test on {endpoint.path} with param '{param_name}'...")
        http_interface = HTTPInterface(api_client.get_url())
        http_interface.add_header(api_client.get_auth_header())
        
        params = {param_name: 99999}
        response = http_interface.send_get(endpoint.path, params=params)

        if 200 <= response.status_code < 300:
            scan_evidence = f"Sent request to {endpoint.path} with parameter '{param_name}=99999'.\nServer responded with status {response.status_code} and a response size of {len(response.content)} bytes."
            sr = ScanResult(
                owasp_category=OWASP_FLAGS.URC.value,
                vulnerability_name="4. Pagination Abuse",
                endpoint=endpoint, severity=risk_level,
                description="The API does not enforce a maximum value on pagination parameters, allowing an attacker to request a huge number of records at once and exhaust server resources.",
                recommendation="Implement and enforce a maximum value for all pagination parameters (e.g., 'limit', 'size'). Return a 400 Bad Request error if the value exceeds the cap.",
                evidence=scan_evidence,
                test_name="Pagination Parameter Fuzzing",
                affected_params=params
            )
            results.append(sr)
            print(f"[!!!] VULNERABILITY FOUND: Pagination abuse on {endpoint.path}")
        else:
            print(f"[OK] Server correctly handled pagination abuse on {endpoint.path} with status {response.status_code}")
    
    return results